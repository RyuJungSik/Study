# 스프링 요약

### Spring DI/IoC는 어떻게 동작하나?

- IoC(제어의 역전)은 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것으로 코드의 최종호출은 개발자가 제어하는 것이 아닌 프레임워크의 내부에서 결정된 대로 이루어진다.
- DI(의존관계 주입)은 Spring 프레임워크에서 지원하는 IoC의 형태로 클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해준다.
- 스프링에서는 스프링 컨테이너 ApplicationContext를 이용하여 설정 정보를 생성, 등록하고 필요한 객체를 생성자 혹은 setter를 통해 주입한다.

### Spring Bean이란 무엇인가?

- IoC 컨테이너 안에 들어있는 객체로 필요할 때 IoC컨테이너에서 가져와서 사용한다.
- @Bean 을 사용하거나 xml설정을 통해 일반 객체를 Bean으로 등록할 수 있습니다.

### 스프링 Bean의 생성 과정을 설명하라

- 객체 생성 → 의존 설정 → 초기화 → 사용 → 소멸 과정의 생명주기를 가지고 있다.
- Bean은 스프링 컨테이너에 의해 생명주기를 관리하며 빈 초기화방법은 @PostConstruct 를 빈 소멸에서는 @PreDestroy 를 사용한다.
- 생성한 스프링 빈을 등록할 때는 ComponentScan을 이용하거나 @Configuration 의 @Bean 을 사용하여 빈 설정파일에 직접 빈을 등록할 수 있다.

### 스프링 Bean의 Scope에 대해서 설명하라

- 빈 스코프는 빈이 존재할 수 있는 범위를 뜻하며 싱글톤, 프로토타입, request, session, application 등이 있다.
- 싱글톤은 기본 스코프로 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.
- 프로토타입은 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다.
- request는 웹 요청이 들어오고 나갈때까지 유지하는 스코프, session은 웹 세션이 생성, 종료할때까지, application은 웹 서블릿 컨텍스트와 같은 범위로 유지하는 스코프이다.

### IoC 컨테이너의 역할은 무엇인가?

- 애플리케이션 실행시점에 빈 오브젝트를 인스턴스화하고 DI 한 후에 최초로 애플리케이션을 기동할 빈 하나를 제공해준다.

### DI 종류는 어떤것이 있고, 이들의 차이는 무엇인가?

- DI는 세가지 방법이 있습니다. 생성자 삽입, Setter를 이용한 메소드 매개 변수 삽입, 필드 주입이 있다.
- 생성자 주입은 생성자 호출시점에 딱 1번만 호출되는 것을 보장하며 불변, 필수 의존관계에 사용한다.
- Setter주입은 선택, 변경 가능성이 있는 의존관계에 사용되며 스프링빈을 선택적으로 등록이 가능하다.
- 필드 주입은 `@Autowired` 를 사용하는데 외부에서 변경이 불가능하여 테스트 하기 힘들다. DI 프레임워크 없이는 작동하기 힘들며, 주로 애플리케이션과 관계없는 테스트코드나 `@Configuration` 같은 스프링 설정 목적으로 사용한다.

### Autowiring 과정에 대해서 설명하라.

- 컨테이너에서 타입(인터페이스 또는 오브젝트)을 이용해 의존 대상 객체를 검색하고 할당할 수 있는 빈 객체를 찾아 주입한다.

### 프론트 컨트롤러 패턴이란 무엇인가?

- 클라이언트의 다양한 요청마다 서블릿을 만들어서 사용한다고 하면 개발과 유지보수의 효율이 떨어질 수 밖에 없다.
- 프론트 컨트롤러 패턴을 사용함으로써 각 요청을 적절한 곳으로 위임해줌으로써 개발과 유지보수의 효율성이 증가하고 모든 요청에 대해 보안, 국제화, 라우팅 및 로그와 같은 일반적인 기능을 한 곳에서 캡슐화할 수 있다.
- Spring에서는 DispatcherServlet이 프론트 컨트롤러 패턴을 사용한 예이며, DispatcherServlet이 Bean으로 등록되어 package를 scan하고 @Controller, @RestController 애노테이션을 확인하여 어떠한 요청이 들어왔을 때 적절한 Handler Method에 위임해준다.

### Servlet Filter와 Spring Interceptor의 차이는 무엇인가요?

- Filter는 Servlet Filter로써 javax.servlet 스펙에 포함되는 클래스이다.
- Filter는 Servlet에서 전후처리를 담당하며, Interceptor는 Spring에서 Handler를 실행하기 전후나, ViewResolver를 통해 컨트롤러에서 리턴한 View Name으로부터 렌더링을 담당할 View 오브젝트를 준비해 돌려준 후 실제 View를 렌더링한 후에 어떠한 처리를 담당한다.
- Filter는 Web Application(Tomcat을 사용할 경우 web.xml)에 등록하며, Interceptor는 Spring의 Application Context에 등록한다.
- Filter는 Method Signature에 있는 Argument인 HttpServletRequest 혹은 HttpServeltResponse를 ServletRequest, ServletResponse 등으로 교체할 때 사용하거나, 데이터 변환(다운로드 파일의 압축 및 데이터 암호화 등), XSL/T를 이용한 XML 문서 변경, 사용자 인증, 자원 접근에 대한 로깅 등에 사용한다.
- Interceptor의 경우 AOP를 흉내내거나, Spring 애플리케이션에서 전역적으로 전후처리 로직에서 예외를 사용하도록 하거나, Handler Method에서 사용자의 권한을 체크해서 다른 동작을 시켜준다거나 할 때 사용한다.

### Spring에서 CORS 에러를 해결하기 위한 방법을 설명하라.

- Servlet Filter를 사용하여 커스텀한 Cors 설정하거나,
- WebMvcConfiguer를 구현한 Configuration 클래스를 만들어서 addCorsMappings()를 재정의할 수도 있고,
- 마지막으로 Spring Security에서 CorsConfigurationSource를 Bean으로 등록하고 config에 추가해줌으로써 해결할 수 있다.
- Controller 클래스에 @Crossorigin 어노테이션을 통해 해결할 수 있다.

### Bean/Component 어노테이션에 대해서 설명해주시고, 둘의 차이점에 대해 설명하라.

- 두 어노테이션 모두 IoC 컨테이너에 Bean을 등록하기 위해 사용한다.
- @Component : 개발자가 작성한 class를 기반으로 실행시점에 인스턴스 객체를 1회(싱글톤) 생성한다.
- @Controller, @Service, @Repository 는 모두 @Component 이며 실행시점에 자동으로 의존성을 주입한다.
- @Bean : 개발자가 작성한 method를 기반으로 메서드에서 반환하는 객체를 인스턴스 객체로 1회(싱글톤) 생성한다.

### POJO란 무엇인가요? Spring Framework에서 POJO는 무엇이 될 수 있을까요?

- POJO는 프레임워크 인터페이스, 클래스를 구현하거나 확장하지 않은 단순한 클래스로
- Java에서 제공하는 API 외에 종속되지 않는다.
- 특정 환경에 종속되지 않아 코드가 간결하고 테스트 자동화에 유리하다.
- 스프링에서는 도메인과 비즈니스 로직을 수행하는 대상이 POJO대상이 될 수 있다.

### Filter는 Servlet의 스펙이고, Interceptor는 Spring MVC의 스펙이다. Spring Application에서 Filter와 Interceptor를 통해 예외를 처리할 경우 어떻게 해야 할까?

- Filter는 DispatcherServlet 외부에 존재하기 때문에 예외가 발생했을 때 ErrorController에서 처리해야 한다.
- 하지만 Interceptor는 DispatcherServlet 내부에 존재하기 때문에 @ControllerAdvice를 적용해서 처리할 수 있다.

### Spring Application을 구동할 때 메서드를 실행시키는 방법에 대해 설명하라.

- CommandLineRunner, ApplicationRunner를 구현한 클래스를 만들어서 실행시키는 2가지 방법이 있다.
- 또한 Spring의 ApplicationEvent를 사용한 방법,
- @Postconstruct를 사용한 방법,
- InitializingBean 인터페이스를 구현하는 방법,
- @Bean의 initMethod를 사용한 방법이 있다.

---

---

### **프레임워크란?**

- 프레임워크란 응용 프로그램이나 소프트웨어 솔루션 개발을 수월하기 위해 **구조, 틀이 제공된 소프트웨어 환경** 이다.

### **Spring이란?**

- 스프링은 **자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크** 이다.
- 동적인 웹 사이트를 개발하기 위한 여러 가지 서비스를 제공하고 있다.
- POJO 기반의 구성으로 자바 코드를 이용해서 객체를 구성하는 방식 그대로 스프링에서 사용할 수 있다.
    - 덕분에 높은 생산성과 유연한 테스트를 할 수 있다.
- DI(의존성 주입)을 통한 객체 관계 구성을 지원한다.
- AOP(횡단 관심사 분리) 지원
- MVC 구조로 계층이 분리되어 관리하기 수월하다.
- 배치 애플리케이션 스프링 배치가 있다.

### **DI (Dependency Injection)란?**

- **DI는 스프링 프레임워크에서 지원하는 IoC의 형태** 이다.
- **클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해주는 것이다.**
- 장점
    - **스프링 자체에서 설정을 통해 연관 관계를 맺어줌으로써 객체간 결합도를 낮춰준다.**
    - **클래스의 재사용성을 높이고, 유지보수가 편리해진다.**
    - 의존성 주입으로 인해 stub, mock 객체를 사용해 unit 테스트의 이점이 생긴다.
- 단점
    - 의존성 주입을 위한 선행 작업이 필요해 간단한 프로그램에서는 번거롭다.
    - **코드 추적이 어렵다.**

### **주입 방식과 특징은?**

- 수정자 주입
    - 대부분 의존 관계 주입은 한번 일어나면 종료시점까지 변경할 일이 거의 없다.
    - Setter를 통해 주입하게 되면 변경될 위험이 존재
    - setter을 public으로 열어야함
- 필드 주입
    - 외부에서 변경이 불가능해서 테스트하기 어렵다.
- 생성자 주입
    - 생성자 주입을 권장
    - 생성자 호출 시점에 딱 1번만 호출되는 것을 보장
    - final 키워드를 통해 불변하게 설계 가능
    - 의존성 주입이 누락되는 것을 방지할 수 있음(IDE에서 컴파일 오류로 알려줌)

### **IoC (Inverse of Control 제어의 역전)란?**

- **객체의 생성부터 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀐 것을 의미**한다.
- 개발자는 프레임워크에 필요한 부품을 개발하고 조립하는 방식으로 개발을 하고 최종 호출은 개발자가 아니라 프레임워크의 내부에서 결정된 대로 이뤄지게 되는데 이런 현상을 제어의 역전이라고 한다.

### **스프링 컨테이너란?**

- **스프링 컨테이너는 자바 객체의 생명 주기를 관리하며, 생성된 자바 객체들에게 추가적인 기능을 제공하는 역할을 한다.**
- 스프링 컨테이너의 종류에는 BeanFactory와 **ApplicationContext** 가 있다.
- 둘 다 빈을 등록하고 생성하고 조회하고 돌려주는 등 빈을 관리하는 역할을 한다.
- ApplicationContext가 BeanFactory의 빈 관리 기능들을 상속받았고, 그 외에 국제화 등의 추가적인 기능을 갖고 있어 스프링 컨테이너라고 하면 보통 ApplicationContext라고 한다.

### Bean이란?

- **컨테이너 안에 들어있는 객체이다.**
- 컨테이너에 담겨있으며, 필요할 때 컨테이너에서 가져와서 사용가능하다.
- @Bean을 사용해 등록하거나 xml을 사용해 등록하고, Bean으로 등록된 객체는 쉽게 주입하여 사용 가능하다.

### **Bean 생명주기란?**

- 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존 관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료 순이다.
- 스프링 컨테이너에 의해 생명주기 관리된다.
- 스프링 컨테이너 초기화 시 빈 객체 생성, 의존 객체 주입 및 초기화된다.
- 생성과 의존관계 주입과 초기화 분리되어있다.
    - 의존관계 주입(생성자 주입)은 필수정보를 받고 메모리 할당을 통해 객채 생성 책임이고
    - 초기화는 생성된 값들을 활용해 외부 커넥션을 연결하는 등 무거운 작업 수행한다.
    - 명확하게 분리하는 것이 유지보수 관점에서 좋다.
- 싱글톤 빈들은 컨테이너가 종료되기 직전에 소멸전 콜백이 발생한다.
- 초기화와 소멸 메서드는 애노테이션으로 **@PostConstruct, @PreDestroy** 를 사용하는 것이 권장된다.

### **빈 스코프**

- 싱글톤 스코프
    - spring 프레임워크의 기본이 되는 스코프이다.
    - 스프링 컨테이너 시작과 종료까지 1개의 객체로 유지한다.
- 프로토타입 스코프
    - 빈의 생성, 의존관계 주입, 초기화까지만 관여하고 이후에는 컨테이너에서 관리하지 않는 스코프이다.
    - 따라서 매번 요청마다 새로 만들어진다.
    - 싱글톤은 스프링이 뜰때 생성되는데 반해, 프로토타입은 **요청할때 생성된다.**
- 웹 스코프
    - request : 각 요청이 들어오고 나갈때까지 유지한다.
    - session : 세션이 생성되고 종료될때까지 유지한다.
    - application : 웹의 서블릿 컨텍스트와 동일한 생명주기를 갖는 스코프이다.
        - 서블릿 컨텍스트는 **web application내에 있는 모든 서블릿들을 관리하며 정보공유할 수 있게 도와 주는 역할** 을 하는데, 톰캣 컨테이너가 실행 시 애플리케이션 하나당 한개의 서블릿컨텍스트가 생성된다.
        - 생명 주기는 보통 톰캣의 시작과 종료와 일치한다.

### 자바코드 **싱글톤 vs 스프링 싱글톤 비교하라**

- 일반코드 싱글톤
    - **private 생성자를 갖고 있어 상속이 불가능하다.**
        - 싱글톤은 자신만이 객체를 생성할 수 있도록 private으로 제한한다. 하지만 상속을 통해 다형성을 적용하기 위해서는 기본 생성자가 필요하므로 private으로 인해 객체지향의 장점을 적용할 수 없다. 또한 싱글톤을 구현하기 위해서는 객체지향적이지 못한 static 필드와 static 메서드를 사용해야 한다.
    - **테스트하기 힘들다.**
        - 싱글톤은 생성 방식이 제한적이기 때문에 Mock 객체로 대체하기 어려우며, 동적으로 객체를 주입하기도 힘들다.
    - **서버 환경에서는 싱글톤이 1개만 생성됨을 보장하지 못한다.**
        - 서버에서 **클래스 로더** 를 어떻게 구성하느냐에 따라 싱글톤 클래스임에도 불구하고 1개 이상의 객체가 만들어질 수 있다. 따라서 자바 언어를 이용한 싱글톤 기법은 서버 환경에서 싱글톤이 꼭 보장된다고 볼 수 없다. 또한 여러 개의 JVM에 분산돼서 설치되는 경우 독립적으로 객체가 생성된다.
    - **전역 상태를 만들 수 있기 때문에 바람직하지 못하다.**
        - 싱글톤의 정적 메서드를 사용하면 언제든지 해당 객체를 사용할 수 있고, 전역 상태로 사용되기 쉽다. 아무 객체나 자유롭게 접근하고 수정하며 공유되는 전역 상태는 객체지향 프로그래밍에서 권장하지 않는다.
- 스프링 싱글톤
    - **객체의 생성을 스프링에 위임함으로써 스프링 컨테이너가 관리하여 자바 언어 레벨에서 직접 구현하기 위한 내용들이 모두 제거되어 앞선 싱글톤의 모든 단점들이 제거된다.**
    - private 생성자가 필요 없어 상속이 가능해진다.
    - 테스트하기 편하다.
    - 프레임워크를 통해 1개의 객체 생성을 보장받을 수 있다.
    - 객체지향적으로 개발할 수 있다.

### **Annotation이란?**

- Annotation은 프로그램에게 추가적인 정보를 제공하는 메타데이터이다.
- **자바 코드에 특별한 의미를 부여한 주석으로 컴파일러를 위한 정보를 제공하기 위한 용도이다.**
- 동작 순서로는
    - 애노테이션 정의
    - 원하는 위치에 배치
    - 코드가 실행되는 중에 Reflection을 이용하여 추가 정보를 획득하여 기능 실시

### Reflection이란?

- Reflection을 사용하면 컴파일 타임에 인터페이스, 필드, 메소드의 이름을 알지 못해도 실행 중에 클래스, 인터페이스, 필드 및 메소드에 접근할 수 있다. 또한 새로운 객체의 인스턴스화 및 메소드 호출을 허용한다.
- **Annotation 자체는 아무런 동작을 가지지 않는 단순한 표식일 뿐이지만, Reflection을 이용하면 Annotation의 적용 여부와 엘리먼트 값을 읽고 처리할 수 있다.**
- **Spring 컨테이너(BeanFactory)에서 객체가 호출되면 객체의 인스턴스를 생성하게 되는데 이 때 필요하게 된다. 즉, 프레임워크에서 유연성있는 동작을 위해 쓰인다.**
- Reflection을 이용하면 Annotation 지정만으로도 원하는 클래스를 주입할 수 있다.

### **웹 서버와 웹 애플리케이션 서버란?**

- 웹 서버
    - 정적 리소스 파일을 제공하는 서버이다.
- 웹 애플리케이션 서버(WAS)
    - 웹 서버가 하는 일 + 애플리케이션 로직(DB 연결, 동작 수행, 데이터 제공)까지 제공하여 동적인 처리를 하는 서버이다.
    - 자바 진영에서는 서블릿 컨테이너 기능을 제공하면 WAS 라고 한다.
    - WAS 안에도 웹 서버가 따로 존재한다.

### **어떻게 하나의 컨트롤러로 여러 요청을 받을까?**

- 컨트롤러는 기본적으로 컴포넌트 스캔되면서 스프링 빈 컨테이너에 올라가있고 싱글톤 패턴으로 구현되어있기 때문에 여러 스레드의 요청이 들어와도 하나의 컨트롤러 객체를 공유하면서 처리한다.
- 여기서 주의할 점은 싱글톤 패턴으로 구현되어 있어 있다는 것은 Thread-Safe하지 않다는 의미이므로 상태를 공유하거나 저장하는 코드가 없도록 Stateless하게 정의해야 한다.
- 결과적으로 내부에는 상태가 존재하지 않으니 메서드에 대한 정보만 같이 공유해서 쓰는 것이다.

### **싱글톤 패턴은 멀티스레드 환경에 어떤 문제가 생길까?**

- 멀티스레드 환경에서 스프링 싱글톤에서 문제가 생겼다면 메서드를 호출하는 환경이 스레드 세이프하게 구현되지 않았다던가, 싱글톤 패턴으로 생성되는 객체가 전역변수를 가졌기 때문이다.
- 싱글톤 패턴은 하나의 객체를 공유하기 때문에 전역변수 같은 것은 되도록이면 사용하지 않아야 한다.
- 이를 해결하는 방법은 다음과 같다.
    - 지역 변수 사용
    - Atomic 자료형 사용
    - ThreadLocal 사용
    - Synchronized 사용

### **AOP(Aspect Oriented Programming)란 무엇인가?**

- 관점 지향 프로그래밍으로 **공통 관심 사항과 핵심 관심 사항을 분리** 하는 것을 의미한다.
- 소스 코드에서 여러 번 반복해서 사용하는 코드(흩어진 관심사)를 Aspect로 모듈화하여 핵심 로직에서 분리해 재사용하는 것이라고 볼 수 있다.
- 여러 객체에 공통으로 적용할 수 있는 기능을 구분함으로써 재사용성을 높여주는 프로그래밍 기법이다.
- 특정 로직(로그, 성능테스트, 권한)을 모든 메서드에 적용하고 싶을 때, 일일이 추가하는 것이 아니라 로직을 만들어서 적용할 수 있다.
- 따라서, 비즈니스 로직 앞/뒤에 공통 관심 사항을 수행해 중복 코드를 줄인다.

### **AOP 적용 방식에 대해서 설명하라.**

- 컴파일 시점
    - .java 파일을 컴파일러를 통해 .class를 만드는 시점에 부가 기능 로직을 추가한다.
    - 모든 지점에 적용 가능하다.
    - AspectJ가 제공하는 특별한 컴파일러를 사용해야 하기 때문에 특별할 컴파일러가 필요한 점과 복잡하다는 단점이 있다.
- 클래스 로딩 시점
    - .class 파일을 JVM 내부의 클래스 로더에 보관하기 전에 조작하여 부가 기능 로직 추가한다.
    - 모든 지점에 적용 가능하다.
    - 특별한 옵션과 클래스 로더 조작기를 지정해야하므로 운영하기 어렵다.
- **런타임 시점**
    - **스프링이 사용하는 방식이다.**
    - 컴파일이 끝나고 클래스 로더에 이미 다 올라가 자바가 실행된 다음에 동작하는 런타임 방식이다.
    - 실제 대상 코드는 그대로 유지되고 프록시를 통해 부가 기능이 적용된다.
    - **프록시는 메서드 오버라이딩 개념으로 동작하기 때문에 메서드에만 적용 가능하고** -> **스프링 빈에만 AOP를 적용 가능하다.**
    - 특별한 컴파일러나, 복잡한 옵션, 클래스 로더 조작기를 사용하지 않아도 스프링만 있으면 AOP를 적용할 수 있기 때문에 스프링 AOP는 런타임 방식을 사용한다.

### **POJO란?**

- 평범한 구식 자바 객체로, **프레임워크 인터페이스나 클래스를 구현하거나 확장하지 않은 단순 클래스**를 의미한다.
- JAVA에서 제공하는 API외에는 종속되지 않아 **코드가 간결하고 테스트 자동화에 유리**하다.
- Spring에서는 **도메인과 비즈니스 로직을 수행하는 대상**이 POJO 대상이 될 수 있다.

### **DAO, DTO란 무엇인가?**

- DAO란
    - DB 데이터를 조회하거나 조작하는 기능을 전담하는 객체이다.
    - DB 접근 로직과 비즈니스 로직을 분리하기 위해서 사용한다.
- DTO란
    - 계층간의 데이터 교환을 위한 객체이다.
    - 로직을 갖지 않는 순수 데이터 객체로 getter, setter만 포함한다.

### **Filter, Interceptor에 대해서 설명하라**

![image](https://user-images.githubusercontent.com/76714485/235704085-cb42d5eb-c728-4ab8-b889-0c48b7f3c4a0.png)

- Filter란?
    - Dispatcher Servlet에 요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 대해 부가작업을 처리하는 기능을 제공하는 것이다.
    - 톰캣과 같은 웹 컨테이너(웹 애플리케이션 WAS 단)에서 동작 하기 때문에 Spring과 무관한 자원에 대해 동작한다.
    - Spring Context 외부에서 동작하므로 ErrorController 에서 예외 처리한다.
- Interceptor란?
    - Spring이 제공하는 기술로, Dispatcher Servlet이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공하는 것이다.
    - 스프링 컨텍스트에서 동작한다.
    - Spring Context 내부에서 동작하므로 @ControllerAdvice 을 사용하여 예외 처리한다.

### **Filter, Interceptor 순서에 대해서 말하라.**

- 1 . 서버 실행 시 Servlet이 올라오는 동안 init 후 doFilter 실행한다.
- 2 . Dispatcher Servlet을 지나쳐 Interceptor의 PreHandler 실행한다.
- 3 . 컨트롤러를 거쳐 내부 로직 수행 후, Interceptor의 PostHandler 실행한다.
- 4 . doFilter 실행한다.
- 5 . Servlet 종료 시 destory한다.

### **Filter, Interceptor둘의 차이는?**

- 관리컨테이너가 필터는 웹 컨테이너이고 인터셉터는 스프링 컨테이너 이다.
- Requset/responde 조작여부가 필터는 가능하고 인터셉터는 불가능하다.
- 용도로는 필터는 보안, 인코딩, 로깅이고, 인터셉터는 인증, 컨트롤러 정보가공, api 호출 로깅이다.

### **AOP와 Interceptor 차이는 무엇인가?**

- 이들의 사용을 구분 짓는 방법은 **파라미터** 이다.
- 모든 메서드의 파라미터와 타입은 제각각이기 때문에 이에 대해 AOP를 적용하게 되면 부가 작업들이 생기게 된다.
- 반면에 Interceptor의 경우 HttpServletRequest, HttpServletResponse를 파라미터로 사용하여 부가 작업이 필요하지 않다.
- 또한, 인터셉터는 Conotroller 앞에서 동작하고 AOP는 Service 앞에서 동작한다.

### 레이어드 아키텍처에 대해서 설명하라.
![image](https://user-images.githubusercontent.com/76714485/235704148-eab940ff-d322-42d8-98b8-7ca808eb2b19.png)

- Spring은 레이어드 아키텍처로 이루어져있다.
- 하나의 레이어는 자신의 고유 역할을 수행하고, 인접한 다른 레이어에 무언가를 요청하거나 응답한다.
- Presentation Layer
    - view를 담당하는 부분으로, 클라이언트와 직접적으로 맞닿는 부분이다.
- Application Layer
    - 비즈니스 핵심 로직을 처리하는 부분이다.
    - Service 객체라는 것은 하나의 트랜잭션으로 구성되어 작동한다.
- Persistence Layer
    - 데이터 관련 처리를 담당하는 부분이다.

### **커넥션 풀이란?**

- 애플리케이션이 데이터베이스를 사용하기 위해서는 커넥션을 맺어야 한다.
- 커넥션을 생성하고 소멸시키는 비용이 크기 때문에 커넥션 풀을 세팅해두고(기본 10) 애플리케이션이 시작하는 시점에 커넥션을 미리 다 만들어 놓고 이를 재활용하면서 사용한다.
- 스프링 부트 2.0부터는 hikariCP를 기본 커넥션 풀로 사용한다.

### D**ataSource란?**

- 커넥션 관련 기술이 여러 개 등장하면서 코드레벨에서는 서로 다르지만 논리적으로는 커넥션을 획득하는 역할을 하기 때문에 이를 추상화 시킨 것이 DataSource이다.
- 실질적인 로직은 DataSource에 의존하도록 하고 구현 기술이 바뀔때 마다 DataSource의 구현체만 바꾸면 되므로 재사용성과 확장성을 높일 수 있다.
- 커넥션 관련 기술은 커넥션을 계속 신규 생성하는 DriverManager, DBCP2 커넥션 풀, HikariCP 커넥션 풀 등이 있다.
- DriverManager는 DataSource를 구현하지 않아서 스프링에서 DriverManagerDataSource라는 구현 클래스를 제공한다.

### **트랜잭션을 추상화하는 이유는?**

- 다양한 데이터 접근 기술이 등장하면서 코드레벨에서는 서로 다르지만 논리적으로는 같은 기능을 수행하기 때문에 트랜잭션을 추상화한다.
- 스프링 트랜잭션 추상화 클래스는 **PlatformTransactionManager** 이다. 보통 **트랜잭션 매니저** 라고 부른다.
- 다양한 접근 기술로는 JDBC, JPA, 하이버네이트 등이 있다.

### **선언적 트랜잭션과 프로그래밍 방식 트랜잭션 차이는?**

- 선언적 트랜잭션은 @Transactional을 의미한다
- 프로그래밍 방식 트랜잭션은 트랜잭션 매니저나 트랜잭션 템플릿 등을 직접 사용해서 프로그래밍 코드를 작성하는 방식이다.
- @Transactional을 사용하면 프록시(메서드 오버라이딩 개념)를 사용하기 때문에 추가적인 코드를 작성할 필요 없이 간편하게 사용할 수 있으므로 대부분 선언적 트랜잭션을 사용한다.

### **@Transactional의 동작방식에 대해서 설명하라.**

- 메서드에 @Transactional을 붙이면 해당 클래스가 빈으로 등록될 때 @Transactional이 붙은 메서드만 트랜잭션 처리되는 메서드로 오버라이딩 한 프록시 객체가 빈으로 등록된다.
- **클래스에 붙으면 클래스의 전체 public 메서드에 트랜잭션 처리가 된 프록시가 빈으로 등록된다.**
- **public이 아닌 다른 접근제한자가 붙은 메서드의 경우는 트랜잭션처리가 되지 않는데 이유는 프록시가 오버라이딩 개념이기 때문에 public으로 열려있지 않고 private 메서드 같은 경우에는 적용이 불가능하다.**

---

---

### **Bean 초기화 방법 3가지말하라**

- 빈 초기화 메소드에 `@PostConstruct` 사용한다.
- `InitializingBean` 인터페이스의 `afterPropertiesSet()` 메소드 오버라이드한다.
- 커스텀 init() 메소드 정의 후 bean어노테이션에 init메소드를 정의한다.

### **Bean 소멸 방법 3가지 말하라.**

- 빈 소멸 메소드에 `@PreDestroy` 사용한다.
- `DisposableBean` 인터페이스의 `destroy()` 메소드 오버라이드한다.
- 커스텀 destroy() 메소드 정의한다.

### 컨테이너란 무엇인가?

- 컨테이너(Container)는 보통 인스턴스의 생명주기를 관리하며, 생성된 인스턴스들에게 추가적인 기능을 제공하도록하는 것이라 할 수 있다.
- 다시말해, 컨테이너란 당신이 작성한 코드의 처리과정을 위임받은 독립적인 존재라고 생각하면 된다.
- 컨테이너는 적절한 설정만 되어있다면 누구의 도움없이도 프로그래머가 작성한 코드를 스스로 참조한 뒤 알아서 객체의 생성과 소멸을 컨트롤해준다.
- Spring 프레임워크는 다른 프레임워크들과 달리 컨테이너 기능을 제공하고 있다. 이와 같은 컨테이너 기능을 제공하는 것이 가능하도록 하는 것이 IoC 패턴이다.

---

---

### **프레임워크가 무엇인가요? 라이브러리와의 차이점은?**

- **제어**
    - 라이브러리 (능동)
        - 라이브러리를 사용하는 코드는 애플리케이션 흐름을 직접 제어한다.
        - **개발자가 라이브러리 코드를 호출하여 전체적인 코드의 흐름을 주도한다.**
    - 프레임워크 (수동) - **제어의 역전**
        - 프레임워크는 거꾸로 코드가 프레임워크에 의해 사용된다.
        - **개발자는 프레임워크 흐름중 핵심 부분만 작성하고 프레임워크가 전체적인 흐름을 주도한다.**
- 목적
    - 둘 다 목적은 코드의 재사용성과 편의성이다.
    - 라이브러리는 재사용성에 더 집중하고, 프레임워크는 기본적인 틀을 제공해주는 것에 집중한다.

### 스프링 사용 하는 이유와 장점은?

- **방대한 문서**
    - 자바진영에서 가장 보편화된 프레임워크. **문서화**가 잘 되어 있다.
- **개발 편의성, 생산성**
    - **비즈니스 로직**에만 집중할 수 있도록 다양한 **애플리케이션 레벨에서의 인프라**를 갖추고 있다. 개발자는 비즈니스 로직에만 집중하면 된다.
    - ex. IoC, AOP, PSA
- **비침투성 - POJO** (관심사 분리) - 객체지향적 특징
    - 비침투성을 지향하기 때문에, **기존의 도메인 부분에 대한 자바 코드를 최대한 건드리지 않고 웹 서비스를 할 수 있다**.
- **엔터프라이즈 프레임워크 - 대용량 트래픽을 처리 검증됨**
    - 또한, 스프링은 검증된 다양한 기능들과 오픈소스 생태계를 지원한다.
    - spring batch나 spring security등과 같이 다양한 하위 프로젝트들을 제공한다.
    - 이는 개발자 입장에서 비즈니스 로직에만 집중할 수 있게 해준다.
- **성능 향상 - 싱글톤 레지스트리**
    - 일반적인 자바 싱글톤의 장점 - 서버 관점
        - 매 요청마다 새로운 객체를 생성해 로직을 수행하면 비용이 너무 높다. (객체를 싱글톤으로 관리하는 것이 성능상 유리)
    - 스프링은 기존 싱글톤의 장점을 모두 취하고, 단점을 모두 배제한 싱글톤 형식의 객체를 사용할 수 있도록 지원한다. (싱글톤 레지스트리)
- **테스트**
    - DI를 통한 테스트 객체를 쉽게 주입해줌으로써 테스트를 쉽게 진행할 수 있다.
    - 통합 테스트를 제공해준다.

### 스프링 핵심원칙을 말해보아라.

- 스프링의 핵심 원칙은 세 가지다. IoC/DI, AOP, PSA
- IoC
    - **Inversion Of Control** (제어의 역전)을 의미하며, **객체의 생성과 생명주기 관리까지 모든 객체에 대한 제어권을 개발자가 아닌 프레임워크에게 위임**한 것을 의미한다.
    - **객체의 생성 책임을 개발자가 가지는 것이 아니라, 프레임워크에 위임했다.** (능동 -> 수동)
    - IoC vs DI
        - **IoC는 DI의 한 형태. -> 객체지향에선 DI를 통해 IoC를 구현한다.**
- DI
    - DI는 **의존관계 주입**을 의미한다. 의존관계란 하나의 객체가 다른 객체의 상태에 따라 영향을 받는 것을 의미한다.
    - 스프링에서는 이러한 **의존관계를 개발자가 직접 관리하지 않고, 스프링 컨테이너에서 관리**한다. 의존관계가 필요할 때마다 **스프링 컨테이너에서 개발자 코드안으로 의존성을 주입해준다.**
    - DI는 스프링에서 IoC를 구현한 한가지 방법이며, **IoC는 DI를 포함하는 개념이다**.
    - 이를 통해 개발자는 **객체의 생성, 생명주기 관리, 의존관계 설정 책임**을 신경쓸 필요없이 **자신의 비즈니스 로직에만 집중**하여 생산성을 높일 수 있다.
- AOP
    - Aspect-Oriented Programming (관점 지향 프로그래밍)을 의미한다.
    - 스프링 DI가 의존성에 대한 주입이라면 AOP는 로직(code)주입이라고 할 수 있다.
    - 관점 지향은 쉽게 말해 **어떤 로직을 핵심적인 관점과 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화**하겠다는 것이다.
        - 핵심적인 관점: 비즈니스 로직
        - 부가적인 관점: 핵심 로직을 실행하기 위해서 행해지는 로직 (로깅, 트랜잭션, 캐싱) - 재사용된다.
- PSA
    - Portable Service Abstraction (일관성 있는 서비스 추상화) 을 의미한다.
    - 서비스 추상화란, **같은 일을 하는 다수의 기술을 공통의 인터페이스로 제어할 수 있게 하는 것**을 의미한다.
    - **외부 환경의 변화에 관계없이 일관된 방식으로 기술에 접근할 수 있게 해주는 것을 의미한다.**
    - 예시
        - `@Cacheable`: 캐시대상으로 redis를 사용하던 ehcache를 사용하던 @Cacheable을 처리하는 내부 코드는 변하지 않는다.
        - `@Transactional`: JPA의 구현체로 hibernate를 이용하던 다른 구현체를 이용하던 @Transactional을 처리하는 내부 코드를 변경할 필요가 없다.

### **Spring vs Spring Boot차이는?**

- Spring boot에서는 spring framework에서 지원하지 않는 여러 기능을 제공한다.
- 자동 설정
    - Spring의 경우 Dispatcher Servlet을 직접 서블릿 컨테이너에 등록해줘야 하며, IoC 컨테이너도 직접 실행해주어야 한다. 이외에도 다양한 의존성(JDBC, JPA 등등)을 수동으로 설정해주어야 한다.
    - Spring Boot는 `@EnableAutoConfiguration`을 통해 `spring-boot-autoconfigure/META-INF/spring.factories`에 명시된 다양한 설정들을 의존성에 따라 빈을 등록해준다. (의존성이 존재할 때만 자동 등록)
    - 또한, Dispatcher Servlet와 IoC 컨테이너와 같은 설정도 자동으로 해준다.
- 쉬운 의존성 관리
    - Spring Boot의 경우 의존성만 주입해주면 Spring Boot가 알아서 설정하여 사용할 수 있게 해준다.
- 내장 톰캣
    - Spring의 경우 직접 톰캣을 시동해주어야한다.
    - SpringBoot의 경우 내장 톰캣을 이용하여 자바 코드를 실행하여 웹 서비스를 할 수 있다.
- 내장 H2
    - SpringBoot는 내장 H2를 빈 형태로 제공한다.

### 생성자 주입을 추천하는 이유는?

- **불변**
    - 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경하지 않는 것이 좋다.
    - 그 이유는 불변을 보장함으로써, 추후에 **발생할 수 있을 버그를 사전에 차단해 주는 효과**를 얻기 때문이다.
- **생성자 주입은 Setter의 단점을 모두 커버한다.**
    - 객체를 만들 때 의존성을 주입해주지 않아도 생성이된다. -> NPE 발생 확률 존재.
    - Setter 주입의 경우 상태가 **불변하지 않기 때문에 실수할 확률이 높다.**
- **스프링에 의존적이지 않다.**
    - 스프링 application context가 없어도 단독으로 테스트 혹은 도메인으로써의 역할을 수행할 수 있다.

### **필드 주입을 추천하지 않는 이유**

- 우선 스프링 공식문서에서도 추천하지 않는다.
- 스프링에 의존적인 코드가 된다. - 스프링은 기본적으로 비침투성(POJO)를 지향한다.
    - 우선 필드 주입은 수정자(Setter)주입과 유사한 방식으로 동작한다.
    - 또한, **필드 주입은 IoC 컨테이너에서 제공해주는 것이므로 컨테이너에 너무 의존적인 코드**가 된다.
    - 만약 **테스트시 application context가 없다면 해당 객체는 테스트가 불가능하다.** (순수 자바 코드 단위 테스트 불가)

### **servlet과 serlvet container에 대해서 설명하라.**

- servlet
    - **Java로 HTTP 요청 및 응답을 처리하기 위한 표준**
    - 서블릿은 클라이언트의 http 요청을 받아 **비즈니스 로직을 수행하고, 적절한 http 응답을 생성하는 자바 객체**이다.
    - 웹페이지를 동적으로 생성하는 역할.
    - 서블릿은 일반 자바 객체와 달리 **서블릿 컨테이너 내에서만 실행**된다.
- servlet container
    - 클라이언트로부터 **http 요청 메시지를 적절하게 파싱 후, 스레드를 생성하여 적절한 서블릿을 실행시키고, 서블릿으로 부터 응답받은 요청 처리 결과를 이용해 http 응답 메시지를 만들어주는 컴포넌트.**
    - **웹 서비스에 필요한 다양한 기능을 제공하며, 개발자로 하여금 비즈니스 로직(serlvet 구현)만 집중할 수 있도록 도와주는 프레임워크**
    - **지원하는 기능**
        - tcp/ip 소켓 연결 및 종료. (통신 지원)
        - http 요청 메시지 파싱 및 응답 메시지 생성.
        - 서블릿 생명주기 관리 (서블릿의 탄생과 죽음을 관리)
        - 멀티스레딩 지원 (요청당 스레드로 처리)
        - 선언적인 보안 관리
    - 대표적인 servlet container: tomcat, netty

### **@ComponentScan 무엇이고 과정을 설명하라.**

- `@ComponentScan`이란
    - **리플렉션 기술**을 활용하여 @Component 혹은 streotype 애노테이션이 붙은 **Class들을 자동으로 scan하여 Bean으로 등록해주는 역할**을 해주는 애노테이션.
    - 스프링부트는 `@ComponentScan`이 붙은 패키지부터 Scan을 한다.
- ComponentScan 과정
    - 스프링 애플리케이션을 동작시키면, 스프링 IoC 컨테이너가 생성된다.
    - 만약 `@ComponentScan`이 붙은 클래스가 있다면, 해당 클래스를 기준으로 하위 패키지에 등록된 모든 `@Component`가 붙은 클래스를 스캔한다.
    - 이때, reflection api를 사용한다.
    - 스캔된 클래스를 IoC 컨테이너에 빈으로 등록한다.

### **DispatcherServlet이란?**

- Front Controller 패턴을 이용하여 Servlet Container(Tomcat)에 들어오는 모든 요청을 받는 Servlet.
- 공통 작업 (인터셉터, 예외 처리, Multipart 처리)를 처리하고 요청에 맞는 핸들러에 작업을 위임하는 Servlet.

### **Connection Pool이 부족한 경우 발생할 수 있는 문제**

- Connection Pool 부족시
    - 모든 요청이 DB에 접근하고 있고 남은 Connection이 없다면 해당 클라이언트는 대기 상태로 전환시키고 Pool에 Connection이 반환되면 대기 상태에 있는 클라이언트에게 순차적으로 제공됨.
- 발생할 수 있는 문제
    - Timeout으로 인한 예외 발생

---

---

### ****Context란?****

- Context는 system을 핸들링 하기위해 존재한다.
- 즉, 리소스 값 처리, 데이터베이스 및 기본 설정에 대한 액세스 권한 획득 등과 같은 서비스를 제공한다.
- Context는 현재 application이 동작하는 동안의 모든 환경을 핸들링한다.

### ****pom.xml이란?****

- 빌드/배포와 관련된 설정을 담고 있는 파일 MAVEN에서 메타 정보로 사용하는 파일
- 자바 라이브러리를 관리하기 위한 저장소

### ****SQL Mapper vs ORM 비교하면?****

- **SQL Mapper**
    - Object와 SQL의 필드을 매핑하여 데이터를 객체화하는 기술.
    - SQL문을 직접 작성하고 쿼리 수행결과를 어떠한 객체에 매핑하여 줄 지 바인딩하는 방법. 즉 SQL 의존적인 방법
    - 대표적인 예로 JdbcTemplate, Mybatis가 있다.
    - 단점으로는
        - SQL을 개발자가 직접 작성하는 문제.
        - DBMS에 종속적인 문제.
        - 비슷한 쿼리를 반복적으로 작성해야하는 문제
        - 객체와 관계형 테이블 구조간 패러다임 불일치 발생.
- **ORM**
    - Object와 DB테이블을 매핑하여 데이터를 객체화하는 기술.
    - CRUD 관련 메소드를 사용하면 자동으로 SQL이 만들어져 개발자가 반복적인 SQL을 직접 작성할 필요가 없다.
    - DBMS에 종속적이지 않다.
    - 복잡한 쿼리의 경우 JPQL을 사용하거나 SQL Mapper를 혼용하여 사용할 수 있다.
    - Java ORM 기술에 대한 인터페이스 표준 : JPA라고 하고, 이를 구현한 가장 대표적인 기술이 Hibernate이다.
    - 장점으로는
        - DBMS에 의존하지 않음으로써 도메인과 비즈니스 로직 설계에 더 집중할 수 있는 장점
        - 요구사항 변화에 빠른 대처 가능한 장점
        - 복잡한 통계성 쿼리보다는 실시간 처리용 쿼리에 적합

### ****Spring WebFlux란?****

- Blocking + 동기 방식으로 동작하는 Spring MVC의 한계점을 극복하기 위해 Spring5에 처음 등장했다.
- 기존의 Spring MVC에서는 HTTP 요청들을 큐에 넣어두고, 멀티쓰레드를 기반으로 동작한다.
- 이러한 방식은 응답성이 상대적으로 떨어지기 때문에 비동기적으로 요청을 처리하기 위한 방법이 필요하게 되었고,       리액티브 프로그래밍을 통해 **비동기 데이터 스트림으로 Non-Blocking 애플리케이션**을 개발하기 위한 Spring WebFlux 프레임워크가 등장했다.

---

---

### **WAS와 WS(web server)의 차이**

- WAS(Web Application Server) : 비지니스 로직을 넣을 수 있다 (Tomcat, PHP, ASP, Net 등)
- WS(Web Server) : 비지니스 로직을 넣을 수 없다 (Nginx, Apache 등)

### Spring MVC 동작 방식은?

![image](https://user-images.githubusercontent.com/76714485/235704357-3db43e98-0753-429e-85f7-c64b48ab955f.png)

- 1. DispatcherServlet이 브라우저로부터 요청을 받는다.
- 2. DispatcherServlet은 요청된 URL을 HandlerMapping 객체에 넘기고,
- 호출해야 할 Controller 메소드(핸들러) 정보를 얻는다.
- 3. DispatcherServlet이 HandlerAdapter 객체를 가져온다.
- 4. HandlerAdapter 객체의 메소드를 실행한다.
- 5. Controller 객체는 비즈니스 로직을 처리하고, 그 결과를 바탕으로 뷰(ex. JSP)에 전달할 객체를 Model 객체에 저장한다. DispatcherServlet에게 view name을 리턴한다.
- 6. DispatcherServlet은 view name을 View Resolver에게 전달하여 View 객체를 얻는다.
- 7. DispatcherServlet은 View 객체에 화면 표시를 의뢰한다.
- 8. View 객체는 해당하는 뷰(ex. JSP, Thymeleaf)를 호출하며, 뷰는 Model 객체에서 화면 표시에 필요한 객체를 가져와 화면 표시를 처리한다.

---

---

****@RequestBody, @RequestParam, @ModelAttribute의 차이를 설명하라.****

- @RequestBody
    - 는 클라이언트가 전송하는 JSON 형태의 HTTP Body 내용을 MessageConverter를 통해 Java Object로 변환시켜주는 역할을 합니다.
    - 값을 주입하지 않고 값을 변환 시키므로(Reflection을 사용해 할당), 변수들의 생성자, Getter,Setter가 없어도 정상적으로 할당된다.
- @RequestParam 은
    - 1개의 HTTP 요청 파라미터를 받기 위해 사용합니다. @RequestParam은 필수 여부가 true이기 때문에,
    - 기본적으로 반드시 해당 파라미터가 전송되어야 합니다. 전송되지 않으면 400Error를 유발할 수 있으며,
    - 반드시 필요한 변수가 아니라면 required의 값을 false로 설정해줘야 합니다.
- @ModelAttribute 는
    - HTTP Body 내용과 HTTP 파라미터의 값들을 생성자,Getter,Setter를 통해 주입하기 위해 사용합니다.
    - 값 변환이 아닌 값을 주입시키므로 변수들의 생성자나 Getter,Setter가 없으면 변수들이 저장되지 않는다.

### ****Spring MVC에 대해 설명해주세요.****

- MVC는 Model, View, Controller의 약자이며, 각 레이어간 기능을 구분하는데 중점을 둔 디자인 패턴입니다.
- **Model은**  (DAO, DTO, Service 등) 데이터 관리 및 비즈니스 로직을 처리하는 부분이며
- **View는** 비즈니스 로직의 처리 결과를 통해 유저 인터페이스가 표현되는 구간입니다.
- **Controller는**  Model과 View는 서로 연결되어 있지 않기 때문에 Controller가 사이에서 통신 매체가 되어줍니다 사용자의 요청을 처리하고 Model과 View를 중개하는 역할을 합니다.
