#

### 자바 특징을 설명하라

- Java는 객체지향 프로그래밍 언어이다.
- 기본 자료형을 제외한 모든 요소들이 객체로 표현되고, 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어이다.
- 장점으로는
    - JVM(자바가상머신) 위에서 동작하기 때문에 운영체제에 독립적이다.
    - GabageCollector를 통한 자동적인 메모리 관리가 가능하다.
- 단점으로는
    - JVM 위에서 동작하기 때문에 실행 속도가 상대적으로 느리다.
    - 다중 상속이나 타입에 엄격하며, 제약이 많다.

### JVM의 역할에 대해 설명하라

- JVM은 스택 기반으로 동작하며, Java Byte Code를 OS에 맞게 해석 해주는 역할을 하고 가비지컬렉션을 통해 자동적인 메모리 관리를 해줍니다.

### 자바 컴파일 과정에 대해 설명하라

- 개발자가 .java 파일을 생성한다.
- build를 한다.
- java compiler의 javac의 명령어를 통해 바이트코드(.class)를 생성한다.
- Class Loader를 통해 JVM 메모리 내로 로드한다.
- 실행엔진을 통해 컴퓨터가 읽을 수 있는 기계어로 해석된다.(각 운영체제에 맞는 기계어)

### 자바에서 제공하는 원시 타입은 무엇이 있고, 각각 몇바이트인가?

- 정수형 byte, short, int, long 실수형 float, double 문자형 char 논리형 boolean이 있고,
- 정수형 1, 2, 4, 8, 실수형 4, 8, 문자형 2, 논리형 1 바이트를 차지한다.

### 오버라이딩과 오버로딩에 대해 설명하라.

- 오버라이딩(Overriding)은 상위 클래스에 있는 메소드를 하위 클래스에서 재정의 하는 것을 말하고,
- 오버로딩(Overloading)은 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메소드를 여러 개 정의하는 것을 말한다.

### 객체지향 프로그래밍에 대해 설명하라.

- 모든 데이터를 객체취급하며, 처리요청을 받은 객체는 객체 그 안의 기능을 사용해 요청을 처리한다.
- 특징으로는 캡슐화, 상속, 다형성, 추상화 등이 있고, 모듈 재사용으로 확장 및 유지보수가 용이하다.

### try-with-resources에 대해 설명하라.

- try-with-resources는 try-catch-finally의 문제점을 보완하기 위해 나온 개념이다.
- try( ... ) 안에 자원 객체를 전달하면, try블록이 끝나고 자동으로 자원 해제 해주는 기능을 말한다.
- 따로 finally 구문이나 모든 catch 구문에 종료 처리를 하지 않아도 되는 장점이 있다.

### 불변 객체가 무엇인지 설명하고, 대표적인 자바의 예시를 설명하라.

- 불변 객체는 객체 생성 이후 내부의 상태가 변하지 않는 객체를 말한다.
- 자바에서는 필드가 원시 타입인 경우 final 키워드를 사용해 불변 객체를 만들 수 있고,
- 참조 타입일 경우엔 추가적인 작업이 필요하다.

### 참조 타입을 불변 객체로 만드는 법은 무엇인가?

- 참조 타입은 대표적으로 1.객체를 참조할 수도 있고, 2.배열이나 3.List 등을 참조할 수 있다.
- 참조 변수가 일반 객체인 경우 객체를 사용하는 필드의 참조 변수도 불변 객체로 변경해야 한다.
- 배열일 경우 배열을 받아 copy해서 저장하고, getter를 clone으로 반환하도록 하면 된다.
    - 배열을 그대로 참조하거나, 반환할 경우 외부에서 내부 값을 변경할 수 있음. 때문에 clone을 반환해 외부에서 값 변경하지 못하게 함
- 리스트인 경우에도 배열과 마찬가지로 생성시 새로운 List를 만들어 값을 복사하도록 해야한다.

### 불변 객체나 final을 사용해야 하는 이유는?

- Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
    - 공유 자원이 불변이기 때문에 항상 동일한 값을 반환하기 때문
- 실패 원자적인 메소드를 만들 수 있다.
    - 어떠한 예외가 발생되더라도 메소드 호출 전의 상태를 유지할 수 있어 예외 발생 전과 똑같은 상태로 다음 로직 처리 가능
- 부수효과를 피해 오류를 최소화 할 수 있다.
- 메소드 호출 시 파라미터 값이 변하지 않는다는 것을 보장할 수 있다.
- 가비지 컬렉션 성능을 높일 수 있다.

### 추상클래스와 인터페이스는 무엇이고 차이점은 무엇인가?

- 추상 클래스는 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우를 말하고,
- 인터페이스는 모든 메소드가 추상 메소드로만 이루어져 있는 것을 말한다.
- 공통점으로는
    - new 연산자로 인스턴스 생성 불가능
    - 사용하기 위해서는 하위 클래스에서 확장/구현 해야 한다.
- 차이점으로는
    - 인터페이스는 그 인터페이스를 구현하는 모든 클래스에 대해 특정한 메소드가 반드시 존재하도록 강제함에 있고,
    - 추상클래스는 상속받는 클래스들의 공통적인 로직을 추상화 시키고, 기능 확장을 위해 사용한다.
    - 추상클래스는 다중상속이 불가능하지만, 인터페이스는 다중상속이 가능하다.

### 가비지 컬렉션에 대해 설명하라.

- 가비지 컬렉션은 JVM의 메모리 관리 기법 중 하나로 시스템에서 동적으로 할당됐던 메모리 영역 중에서 필요없어진 메모리 영역을 회수하여 메모리를 관리해주는 기법이다.

### 자바의 메모리 영역에 대해 설명하라.

- 자바의 메모리 공간은 크게 Method 영역, Stack 영역, Heap 영역으로 구분되고, 데이터 타입에 따라 할당된다.
- **메소드(Method) 영역** : 전역변수와 static변수를 저장하며, Method영역은 프로그램의 시작부터 종료까지 메모리에 남아있다.
- **스택(Stack) 영역** : 지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제된다. LIFO(Last In First Out) 구조를 갖고 변수에 새로운 데이터가 할당되면 이전 데이터는 지워진다.
- **힙(Heap) 영역** : new 키워드로 생성되는 객체(인스턴스), 배열 등이 Heap 영역에 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.

### 각 메모리 영역에 할당되는 시점은 언제인가?

- Method 영역 : JVM이 동작해서 클래스가 로딩될 때 생성
- Stack 영역 : 컴파일 타임 시 할당
- Heap 영역 : 런타임시 할당

### 클래스와 객체에 대해 설명하라.

- 클래스는 객체를 만들어내기 위한 설계도 혹은 틀 이라고 할 수 있고, 객체를 생성하는데 사용한다.
- 객체는 설계도(클래스)를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 갖는다.
- 여기서 상태는 필드(fields), 행동은 메소드(Method)라고 표현한다.
- 객체에 메모리가 할당되어 실제로 활용되는 실체는 '인스턴스'라고 부른다.

### 생성자에 대해 설명하라

- 생성자는 클래스와 같은 이름의 메소드로, 객체가 생성될 때 호출되는 메소드이다.
- 명시적으로 생성자를 만들지 않아도 default로 만들어지며, 생성자는 파라미터를 다르게하여 오버로딩할 수 있다.

### Wrapper Class란 무엇이며, Boxing과  UnBoxing은 무엇인가?

- 기본 자료형(Primitive data type)에 대한 객체 표현을 Wrapper class라고 한다.
- 기본 자료형 → Wrapper class로 변환하는 것을 Boxing이라 하며,
- Wrapper class → 기본 자료형으로 변환하는 것을 UnBoxing이라 한다.

### Synchronized에 대해 설명하라.

- 여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드를 제외하고 나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념이다.
- 데이터의 thread-safe를 하기 위해 자바에서 Synchronized 키워드를 제공해 멀티 쓰레드 환경에서 쓰레드간 동기화를 시켜 데이터의 thread-safe를 보장한다.
- Synchronized는 변수와 메소드에 사용해서 동기화 할 수 있으며, Synchronized 키워드를 남발하게 되면 오히려 프로그램의 성능저하를 일으킬 수 있다.

### new String과 리터럴””의 차이를 설명하라.

- new String()는 new키워드로 새로운 객체를 생성하여서 Heap 메모리 영역에 저장된다.
- 반면 “”리터럴은 Heap안에 있는 String Constant Pool 영역에 저장된다.

### String, StringBuffer, StringBuilder의 차이를 설명하라.

- String은 불변의 속성을 가지며, StringBuffer와 StringBuilder는 가변의 속성을 가진다.
- StringBuffer는 동기화를 지원하여 멀티 쓰레드 환경에서 주로 사용하며,
- StringBuilder는 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 사용한다.

### String 객체가 불변인 이유는?

- 캐싱 기능에 의한 메모리 절약과 속도 향상 때문
- thread-safe
- 보안 기능  등의 이유 때문이다.

### 접근 제한자에 대해 설명하라

- 변수 또는 메소드의 접근 범위를 설정해주기 위해서 사용하는 Java의 예약어를 의미하며, 총 4 가지 종류가 있다.
- public - 접근 제한이 없다. (같은 프로젝트 내 어디서든 사용 가능)
- protected - 해당 패키지 내, 다른 패키지에서 상속받아 자손 클래스에서 접근 가능하다.
- (default) - 해당 패키지 내에서만 접근 가능
- private - 해당 클래스에서만 접근 가능

### 클래스 멤버 변수 초기화 순서에 대해 설명하라

- static 변수 선언부 : 클래스가 로드 될 때 변수가 제일 먼저 초기화 된다.
- 필드 변수 선언부 : 객체가 생성될 때 생성자 block 보다 앞서 초기화 된다.
- 생성자 block : 객체가 생성될 때 JVM이 내부적으로 locking( thread-safe 영역 )

### static에대해 설명하라.

- static 키워드를 사용한 변수나 메소드는 클래스가 메모리에 올라갈 때 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용할 수 있다. 즉, 인스턴스(객체) 생성 없이 바로 사용 가능하다.
- 모든 객체가 메모리를 공유한다는 특징이 있고, GC 관리 영역 밖에 있기 때문에 프로그램이 종료될 때까지 메모리에 값이 유지된 채로 존재하게 된다.

### static 을 사용하는 이유는?

- static은 자주 변하지 않는 값이나 공통으로 사용되는 값 같은 공용자원에 대한 접근에 있어서 매번 메모리에 로딩하거나 값을 읽어들이는 것보다 일종의 '전역변수'와 같은 개념을 통해 접근하는 것이 비용도 줄이고 효율을 높일 수 있다.
- 인스턴스 생성 없이 바로 사용 가능하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리할 때 이용한다.

### Inner Class 내부클래스 장점은 무엇인가?

- 내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있다.
- 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 코드의 캡슐화를 증가시킨다.
- 외부에서는 내부 클래스에 접근할 수 없으므로, 코드의 복잡성을 줄일 수 있다.

### 리플렉션이란 무엇인가?

- 리플렉션이란 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API 이다.

### 리플렉션은 어떤 경우에 사용하는가?

- 코드를 작성할 시점에는 어떤 타입의 클래스를 사용할지 모르지만, 런타임 시점에 지금 실행되고 있는 클래스를 가져와서 실행해야 하는 경우 사용된다.

### Error와 Exception의 차이를 설명하라.

- Error는 실행 중 일어날 수 있는 치명적 오류를 말한다. 컴파일 시점에 체크할 수 없고, 오류가 발생하면 프로그램은 비정상 종료되며 예측 불가능한 UncheckedException에 속한다.
- 반면,Exception은 Error보다 비교적 경미한 오류이며, try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있다.

### CheckedException과 UncheckedException의 차이는 무엇인가?

- CheckedException은 실행하기 전에 예측 가능한 예외를 말하고, 반드시 예외 처리를 해야 한다.
    - 대표적인 Exception - IOException, ClassNotFoundException 등
- UncheckedException은 실행하고 난 후에 알 수 있는 예외를 말하고, 따로 예외처리를 하지 않아도 된다.
    - 대표적인 Exception - NullPointerException, ArrayIndexOutOfBoundException 등
- RuntimeException은 UncheckedException을 상속한 클래스이고, RuntimeException이 아닌 것은 CheckedException을 상속한 클래스 이다.

### 컬렉션 프레임워크에 대해 설명하라.

- 다수의 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미한다.
- 자바 컬렉션에는 List, Set, Map 인터페이스를 기준으로 여러 구현체가 존재하고, 이에 더해 Stack, Queue 인터페이스도 존재한다.

### Set과 Map 타입이 Wrapper Class가 아닌 Objec를 받을때 중복 검사는 어떻게 할건지 설명하라.

- hashCode() 메소드를 오버라이딩하여 리턴된 해시코드 값이 같은지를 보고 해시코드 값이 다르다면 다른 객체로 판단하고,
- 해시코드 값이 같으면 equals() 메소드를 오버라이딩하여 다시 비교한다. 이 두 개가 모두 맞으면 중복 객체이다.

### Vector와 List의 차이는?

- 벡터는 데이터 삽입시 원소를 밀어내지만 리스트는 노드를 연결만 하기 때문에, 삽입 삭제 부분에서 리스트가 시간복잡도의 우위를 가진다.
- 벡터는 랜덤부분접근이 가능하지만 리스트는 더블링크드리스트(노드가 양쪽으로 연결)로 되어있기 때문에 랜덤 접근이 되지 않는다. 검색적인 측면에서는 벡터가 우위에 있다.
- 벡터는 리스트와 달리 항상 동기화되는 장점이자 단점을 가지고 있다. 멀티 쓰레드 환경에서 안전하게 객체를 추가하고 삭제할 수 있지만, 단일쓰레드 환경 일때도 동기화를 하기 때문에 List보다 성능이 떨어진다.

### 제네릭에 대해 설명해주고, 왜 쓰는지 말해라

- 제네릭은 데이터의 타입을 하나로 지정하지 않고 사용할 때마다 범용적이고 포괄적으로 지정한다는 의미이다.
- 제네릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있어 에러를 사전에 방지할 수 있다.

### final, finally, finalize의 차이는 무엇인가?

- **final**은 클래스, 메소드, 변수, 인자를 선언할 때 사용할 수 있으며, 한 번만 할당하고 싶을 때 사용한다.
    - final 변수는 한 번 초기화되면 그 이후에 변경할 수 없습니다.
    - final 메소드는 다른 클래스가 이 클래스를 상속할 때 메소드 오버라이딩을 금지한다.
    - final 클래스는 다른 클래스에서 이 클래스를 상속할 수 없다.
- **finally**는 try-catch와 함께 사용되며, try-catch가 종료될 때 finally block이 항상 수행되기 때문에 마무리 해줘야 하는 작업이 존재하는 경우에 해당하는 코드를 작성해주는 코드 블록이다.
- **finalize**는 Object 클래스에 정의되어 있는 메소드이며, GC에 의해 호출되는 메소드로 절대 호출해서는 안되는 메소드이다. GC가 발생하는 시점이 불분명하기 때문에 해당 메소드가 실행된다는 보장이 없고, finalize() 메소드가 오버라이딩 되어 있으면 GC가 이루어질 때 바로 Garbage Collectiong 되지 않는다. GC가 지연되면서 OOME(Out of Memory Exception)이 발생할 수 있기 때문에 finalize() 메소드를 오버라이딩하여 구현하는 것을 권장하지 않고 있다.

### 직렬화에 대해 설명하라.

- 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술이며, 반대로 직렬화된 바이트 형태의 데이터를 다시 객체로 변환하는 과정을 '역직렬화'라고 한다.
- 즉, JVM의 메모리에 상주(힙 or 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술이다.

### SerialVersionUID를 선언해야 하는 이유를 설명해라

- JVM은 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여하는데, 만약 그 시점에 클래스의 정의가 바뀌어 있다면 새로운 버전 번호를 할당하게 된다. 그래서 직렬화할 때의 버전 번호와 역직렬화를 할 때의 버전 번호가 다르면 역직렬화가 불가능하게 될 수 있기 때문에 이런 문제를 해결하기 위해 SerialVersionUID를 사용한다.
- 만약 직렬화할 때 사용한 SerialVersionUID의 값과 역직렬화 하기 위해 사용했던 SVUID가 다르다면 InvalidClassException이 발생할 수 있다.

---

### 자바의 장단점을 설명하시오

- 자바의 장점으로는
    - JVM을 이용한 플랫폼 독립적이다.
    - 포인터 연산이 없어 안정석있는 코드 작성을 할 수 있다.
    - 객체지향 프로그래밍을 지원한다.
    - 다양한 기본클래스, 멀티쓰레딩, 네트워킹 API 지원한다.
- 단점으로는
    - 자바를 실행하려면 JVM실행이 필수인데 많은 메모리를 소모하고 실행속도가 빠르지 않다.
    - 바이트코드를 기계코드로 변환하는 과정에서 일반적 컴파일 언어로 작성된 프로그램보다 속도가 느리다.

### 기본 자료형과 참조자료형에 대해 설명하라.

- 가본자료형은
    - byte, short, int, long, float, double, char, boolean이 존재한다.
    - 생성한 변수에는 값 자체가 저장된다.
    - 사용전에 반드시 선언되어야 하며 null 값을 갖을 수 없다.
- 참조 자료형은
    - class, interface, array, enum이 존재한다.
    - 생성한 변수에는 객체의 주소값이 저장된다.
    - 생성자를 이용하여 새로운 객체의 주소를 가리키거나 null 값을 통해 해제가능하다.

### final 키워드의 다양한 쓰임새를 설명하라.

- 변수에 final을 사용시 해당 변수를 상수화 할 수 있고, 초기화만 가능하며, 이후 새로운 값으로 변경이나 재할당이 불가능하다.
- 클래스에 final 키워드를 사용하면 해당 클래스를 상속할 수 없고, abstract와 기능적충돌로 같이 사용할 수 없다.
- 클래스의 메소드에 final 키워드를 사용하면 해당 메소드를 오버라이딩 할 수 없다.

### 컬렉션 클래스에서 제네릭을 사용하는 이유는?

- 컬렉션 클래스에서 제네릭을 사용하면 컴파일러는 특정 타입만 포함될 수 있도록 컬렉션을 제한한다.
- 컬렉션 클래스에 저장하는 인스턴스 타입을 제한하여 런타임에 발생할 수 있는 잠재적인 모든 예외를 컴파일 타임에 잡아낼 수 있도록 도와준다.

### 자바에서 쓰레드를 구현하기 위한 2가지 방법을 설명하라.

- lang 패키지내에 구현되어있는 Thread 클래스를 상속받거나
- Runnable 인터페이스를 상속받아 run 메소드를 재정의하여 구현한다.

### 자바에서 쓰레드의 동기화와 데드랑을 설명하라.

- 2개 이상의 쓰레드가 하나의 공유 자원에 접근하여 값을 변경할때, 동기화를 적용하지 않으면 값이 옳바르지 못하게 변경될 수 잇다.
- 이런경우를 대비해 synchronized 키워드, 블록을 설정하여 하나의 쓰레드가 공유자원을 점유하고 있을경우 다른 쓰레드가 잠시 대기상태에 머무르도록 할 수 있다.
- 데드락이란 두 쓰레드가 모두 대기 상태 계속 머무르게 되는 현상을 말한다.

### 가비지 컬렉션에 대해서 자세히 설명하라.

- 가바지 컬렉션은 크게 minor, major로 나뉜다.
- minor에서는 new 영역을 대상으로 실행된다.
    - 첫째 new 영역 안의 eden 영역이 가득 차면 survivor1 영역으로 이동시킨 후 나머지 영역의 객체를 삭제한다.
    - 둘째 eden 영역과 survivor1 영역이 기준치 이상으로 찼을경우 참조가 실제로 되고 있는지 검사 후 참조되는 객체만 survivor2 영역에 복사 후 나머지 영역의 객체를 삭제한다.
    - 마지막으로 일정시간 참조되고 있는 객체들을 old 영역으로 이동시킨다.
- major에서는 old 영역을 대상으로 실행된다.
    - major에 비해 시간이 오래 걸리며 old 영역이 가득차 프로세스가 정지될 가능성이 있는경우 실행된다.
    - old 영역에 있는 모든 객체를 검사하여 참조되지 않는 객체들을 한번에 삭제한다.

### NIO을 설명하시오

- NIO는 기존의 자바 IO의 단점을 보완한 새로운 IO 패케지를 의미한다.
- non-blocking IO를 지원하는 특징이 있다.
    - 모든 IO에 대해 쓰레드를 생성하는 방식이 아닌 채널관리자를 사용하여 실제 IO가 발생한 채널만 쓰레드를 생성하여 관리하는 방식이다.

### 자바의 형변환 규칙은 어떻게 되는지 설명하시오

- 형변환에는 묵시적 형변환과 명시적 형변환으로 나뉜다.
- 묵시적 형변환으로는
    - 자바에서는 작은 단위를 큰단위로 바꾸는 경우 묵시적 형변환을 지원합니다.
    - 상속관계에서 하위객체를 상위 겍체로 변환하거나
    - int형 변수를 double형 변수르 변환할 때 적용된다.
- 명시적 형변환은
    - 큰 단위에서 작은 단위로 바꾸는 경우 명시적 형변환을 프로그래머가 정의해주어야 한다.
    - 이럴때 데이터 일부가 유실될 수 있다.

---

### 멤버 변수와 지역 변수에 대해서 설명하라

- 멤버 변수
    - 클래스 블록 영역에 선언되는 변수이다.
    - 크게 static인 변수아 아닌변수로 나뉜다.
- 멤버 변수 static - O
    - 클래스 변수, 공통변수, 정적변수, 전역변수
    - 컴파일시에 메모리할당, 프로그램 종료시 메모리 해제
    - 클래스 전체에서 사용 가능
    - 클래스의 모든 인스턴스가 같은 저장공간을 가리킨다
    - 저장공간 : Method 영역
- 멤버 변수 static - X
    - 인스턴스 변수
    - 객체 생성시마다 따로 저장되는 변수
    - 저장공간 : Heap 영역
    - GC가 관리한다
- 지역 변수
    - 메소드 블록 영역 혹은
    - 저장 공간 stack 영역 이다.

### non -static 멤버와 static 멤버의 차이를 설명하라.

- static 멤버
    - 공간적 특성으로는 멤버는 클래스당 하나 생성한다
        - 객체 내부에 생성되는것 이아니고 컴파일시 method영역에 고정적으로 메모리 할당한다
        - 클래스 멤버이다.
    - 시간적 특성으로는 클래스 로딩 시에 멤버 생성한다.
        - 컴파일시 생성, 프로그램 종료시 메모리 해제한다.
        - 객체 생성 하지 않고도 사용가능하다.
        - 객체가 사라져도 멤버는 사라지지않는다.
    - 공유의 특성으로는 동일한 클래스의 모든 객체들에 의해 공유된다
- non-static 멤버로는
    - 공간적 특성으로는 멤버는 객체마다 별도로 존재한다.
        - 인스턴스 멤버 라고 부른다
        - heap 영역 (클래스 내부에서 선언시) or statck 영역(메소드 내에서 생성시) 에 생성한다.
    - 시간적 특성으로는 객체 생성시 멤버 생성한다.
        - 객체 생성 후에 사용 가능하다.
        - 객체가 사라지면 메모리에서 해제한다.
    - 공유의 특성 으로는 공유를 하지않는다.
        - 멤버는 객체 내에서 각각의 공간을 유지한다.

### **set, list, map의 차이와 각각의 인터페이스 구현체의 종류를 설명하라**

Map

- 검색할 수 있는 인터페이스이다.
- 데이터를 삽입할 때 Key와 Value의 형태로 삽입되며, Key를 이용해서 Value를 얻을 수 있다.
- HashMap, LinkedHashMap, HashTable, TreeMap의 클래스가 있다.

Collection

- List가 있다
    - 순서가 있는 Collection이고
    - 데이터를 중복 해도 된다.
- Set
    - 집합적인 개념의 Collection이다.
    - 순서 없고
    - 데이터를 중복하지 않는다.
    - HashSet, LinkedHashSet(순서o), TreeSet(이진 검색트리-레드 블랙트리로 구현)클래스가 있다.

### **Comparable, Comparator 차이는 무엇인가?**

- Comparable은 기본적으로 정렬할때 사용한다. compareTo()를 오버라이딩한다.
- Comparator는 기본외에 다른 방법으로 정렬할때 사용한다. compare()오버라이딩한다.

### **java8에서 달라진 점은?**

- JAVA 7 부터 지원되는것들로는
    - Diamond Operator을 사용가능하고
    - swith문에 string자료형 사용 가능하고
    - 사용한 리소스를 .close()를 이용해서 수동으로 관리하던것을, try문에 선언하면 자동으로 관리가능하다.
- JAVA 8 부터 지원되는것들로는
    - Lambda Expressions과
    - Stream API과
    - interface에 default method 생성 가능해  졌고
    - new Date and Time API 새롭게 생기고
    - Permanent Heap 영역이(메모리 크기 고정) 제거되었다.

### this 키워드에대해서 설명하라.

- this는 자기 자신을 의미하는 키워드이다.
- this.은 class내의 변수와 메소드의 매개변수가 동일할 때, class내의 멤버임을 명확하게 해준다.
- this()는 자신의 생성자를 호출할때 사용하고, 호출하는 곳의 첫번째 문장에 작성해야한다.

### **리틀엔디안 빅엔디안에 대해서 설명하라.**

- Little Endian은
    - 메모리의 첫 주소에 하위 데이터(데이터의 맨 오른쪽)부터 저장한다.
    - 연산이 적다
    - 인텔이 리틀엔디안을 사용한다
- Big Endian은
    - 메모리의 첫 주소에 상위 데이터(데이터의 맨 왼쪽)부터 저장한다.
    - 사람이 읽는 방법이다.
    - 디버그는 빅엔디안이 편하다.
    - 서버쪽에서 많이 사용하는것이다. 주로 IBM

---

### JVM 구조에대해서 설명하라.

- VM의 구조는 Class Loader, Execution engine, Runtime Data Area, JNI, Native Method Library로 이루어져 있다.
- 클래스 로더는  JVM내로 클래스를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다.
- 실행 엔진은 바이트 코드를 실행시키는 역할을 한다.
    - 인터프리터: 바이트 코드를 한줄 씩 실행한다.
    - JIT 컴파일러는 인터피르의 효율을 높이기 위한 컴파일러로 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러가 반복되는 코드를 네이티브 코드로 바꿔준다. 그 다음부터 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용한다.
    - GC(Garbage Collector): 가비지 컬렉터로 힙 영역에서 사용되지 않는 객체들을 제거하는 작업을 의미한다.
- Runtime Data Areas는 프로그램 실행 중에 사용되는 다양한 영역이다.
    - PC Register는 Thread가 시작될 때 생성되며 현재 수행 중인 JVM 명령의 주소를 갖고 있다.
    - Stack Area는 지역 변수, 파라미터 등이 생성되는 영역이다. 실제 객체는 Heap에 할당되고 해당 레퍼런스만 Stack에 저장된다.
    - Heap Area는 동적으로 생성된 오브젝트와 배열이 저장되는 곳으로 GC의 대상 영역이다.
    - Method Area는 클래스 멤버 변수, 메소드 정보, Type 정보, Constant Pool, static, final 변수 등이 생성된다. 상수 풀(Constant Pool)은 모든 Symbolic Reference를 포함하고 있다.
- JNI(Java Native Interface)는 자바 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공해준다. Native 키워드를 사용하여 메서드를 호출한다. 대표적인 메서드는 Thread의 currentThread()이다.
- Native Method Library: C, C++로 작성된 라이브러리이다.

### **클래스, 객체, 인스턴스의 차이를 말해라**

- 클래스 (Class)는
    - 객체를 만들어 내기 위한 **설계도** 혹은 틀이다.
    - 연관되어 있는 변수와 메서드의 집합이다.
- 객체 (Object)는
    - 소프트웨어 세계에서 구현할 대상이다.
    - 클래스에 선언된 모앙 그대로 생성된 실체
    - '클래스의 인스턴스(instance)' 라고도 부른다.
    - 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.
    - OOP 의 관점에서 클래스의 타입으로 선언되었을 때 '객체' 라고 부른다.
- 인스턴스 (Instance)
    - 설계도를 바탕으로 소프트웨어 세계에서 구현된 구체적인 실체이다.
    - 즉, 객체를 소프트웨어에 실체화 하면 그것을 '인스턴스'라고 부른다.
        - 실체화 된 인스턴스는 메모리에 할당된다.
    - 인스턴스는 객체에 포함된다고 볼 수 있다.
    - OOP의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 '인스턴스'라고 부른다.
    - 추상적인 개념(또는 명세)과 구체적인 객체 사이의 관계에 초점을 맞출 경우에 사용한다.
        - *'~의 인스턴스'*의 형태로 사용된다.*객체는 클래스의 인스턴스다.*객체 간의 링크는 클래스 간의 연관 관계의 인스턴스이다.실행 프로세스는 프로그램의 인스턴스이다.
- 즉, 인스턴스라는 용어는 반드시 클래스와 객체 사이의 관계로 한정지어서 사용할 필요는 없다.

### 어노테이션에 대해서 설명하라.

- 어노테이션은 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있다.
- built-in annotation은 상속받아서 메소드를 오버라이드 할 때 나타나는 @Override 어노테이션이 그 대표적인 예이다.
- 메타 어노테이션은 어노테이션을 선언할 때 사용하는 어노테이션입니다.
- @Retention: 애노테이션 유지 범위를 지정한다. (소스, 클래스, 런타임)
- @Inherit: 애노테이션을 하위 클래스까지 전달여부를 지정한다. 이 애노테이션이 있으면 하위 클래스까지 상속이 가능하다.
- @Target: 해당 애노테이션을 어디에 사용할 지 결정한다. (타입, 필드, 메서드, 파라미터, 생성자, 로컬변수, 애노테이션 타입)

### try-with-resource에 대해서 설명하라.

- 자바 7 버전 이전에서 하나 이상의 리소스를 사용할 경우 개발자가 임의로 finally 문에서 close()를 사용하여 자원 해제를 시켜줘야 했다.
- 이를 해결하기 위해 try() 안에 사용할 리소스 객체를 명시적으로 선언하여 사용하면, JVM에서 자동으로 자원을 반납해주는 기능을 하도록 도입하였다.

### 강한 결합과 느슨한 결합이 무엇인지 설명하라.

- 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 정보를 알고 있는지에 대한 척도이다.
- 어떤 모듈이 다른 모듈에 너무 자세한 부분(구현 세부사항)까지 알고 있을 경우에 강한 결합도를 가진다고 한다.
- 어떤 모듈이 다른 모듈에 대해 필요한 정보(인터페이스로 추상화된 고수준 정책)만 알고 있다면 두 모듈은 낮은 결합도를 가진다고 한다.
- 강한 결합도는 반드시 지양해야 한다.

### 직렬화와 역직렬화에 대해서 설명하라.

- 직렬화란 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터 변환하는 기술과 바이트로 변환된 데이터를 다시 변환하는 기술(역직렬화)을 아울러서 이야기 한다.

### Mutable 객체와 Immutable 객체의 차이점에 대해 설명하라.

- Mutable 객체는 변경 가능 객체이고, Immutable 객체는 불변 객체라고 흔히들 말한다.
- Mutable 객체는
    - 도메인 개체(도메인 클래스 혹은 엔터티)로 사용된다.
    - Mutable 객체의 변경 메서드는 Command method라고도 부르며
    - 리턴 타입을 void 로 정의한다.
    - 또한 void 리턴 타입의 어떠한 상태를 변경하는 메서드는 모두 Command method의 상징이다.
- Immutable 객체는
    - 불변객체이며 값 객체, 서비스 객체 등에 사용된다.
    - Immutable 객체의 변경 메서드는 변경한 객체의 복사본을 반환해야 한다.

### 자바에서 null을 안전하게 다루는 방법에 대해 설명하라

- 공개 메서드가 아닌 곳에는 assert를 사용하여 null을 방어할 수 있다.
- 또한 메서드의 인자를 받을 때 Objects.requireNonNull()을 사용하여 방어할 수 있다.
- Optional을 사용해 리턴 타입에서 null을 반환하지 않도록 방어할 수 있다.
- 마지막으로 사전 조건과 사후 조건을 명확히 하여 계약에 의한 설계를 실천해야 한다.

---
