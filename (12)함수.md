# 12. 함수

## 1. 함수란?

- 스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로퍼 타입, 모듈화 등이 모두 함수와 깊은 관련이 있다.
- 프로그래밍 언어의 **함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.**
- 함수 내부로 입력을 전달받는 변수를 매개변수, 입력을 인수, 출력을 반환값이라 한다.

![Untitled](https://user-images.githubusercontent.com/76714485/133110023-95fd956c-42d9-4ee2-86a3-6993169d6af7.png)


- 함수는 함수 정의 를 통해 생성한다.
- 실행을 위해 **함수 호출(function call/invoke)를 해야한다.**

## 2. 함수의 사용 이유

- 함수는 여러 번 호출할 수 있다. 실행 시점을 개발자가 결정할 수 있다.
- 코드의 재사용이라는 측면에서 매우 유용하다.
- 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다.
- 함수 이름은 함수 자신의 역할을 잘 설명해야 한다. → 코드 가독성 높인다.

## 3. 함수 리터럴

- 자바스크립트의 함수는 객체 타입의 값이다.
- 함수는 함수 리터럴로 생성할 수 있다.
- 함수 리터럴은 function 키워드, 함수 이름 , 매개변수 목록, 함수 몸체 구성된다.
- 

```jsx
var f=function add(x, y){
	return x+y
};
```

- 함수 이름
    - 함수 이름은 식별자다. 따라서 네이밍 규칙을 준수해야한다.
    - 함수 이름은 함수 몸체 내에서만 참소할 수 있는 식별자다
    - 함수 이름은 생략할 수 있다. 기명함수, 익명함수로 나뉜다.
- 매개변수 목록
    - 0개 이상의 배개변수를 고솰호로 감싸고 쉼표로 구분한다.
    - 각 매개변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당된다. 즉 매개변수 목록은 순서에 의미가 잇다.
    - 매개 변수는 함수 몸체 내에서 변수와 동일하게 취급한다. 네이밍 규칙 준수해야 한다.
- 함수 몸체
    - 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다.
    - 함수 몸체는 함수 호출에 의해 실행된다.
- **함수는 객체다.**
- 함수는 일반객체와 다르게 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.

## 4. 함수 정의

- 함수를 정의하는 방법에는 4가지가 있다.
- 함수 선언문

    ```jsx
    function add(x, y){
    	return x+y
    };
    ```

- 함수 표현식

    ```jsx
    var add=function(x, y){
    	return x+y
    };
    ```

- Function 생성자 함수

    ```jsx
    var add=new Function('x', 'y', 'return x+y')
    ```

- 화살표 함수 ES6

    ```jsx
    var add=(x,y)=>x+y
    ```

### 4.1 함수 선언문

```jsx
function add(x, y){
	return x+y
};

//console.dir은 함수 객체의 프로퍼티 가지 출력한다.
console.dir(add); // f add(x,y)
console.log(add(2,5))//7
```

- 함수 선언문은 함수 이름을 생략할 수 없다.
- 함수 선언문은 표현식이 아닌 문이다.
- 즉 크롬개발자 도구의 콘솔에서 함수 선언문을 실행하면 완료 값 undefined가 출력된다.
- 표현식이 아닌 문은 변수에 할달할 수 없다.
- 하지만 아래 코드를 보면 변수에 할당되는 것처럼 보인다.

```jsx
var add=funtion add(x,y){
	return x+y;
}
```

- 이렇게 동작하는 이유는 자바스크립트 엔진이 코드의 문맥에 따라
- 동일한 함수 리터럴을 표현식이 아닌 문인 함수 선언문으로 해석하는 경우와
- 표현식인 문인 함수 리터럴 표현식으로 해석하는 경우가 있기 때문이다.
- 함수 선언문은 함수 이름을 생략할 수 없다는 점을 제외하면 함수 리터럴과 형태가 동일하다. 이는 함수 이름이 있는 기명 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 가능성이 있다는 의미다.
- {}→ 블록문, 객체리터럴 중의적 표현이다. → 문맥에 따라 달라진다.
- 기명 함수 리터럴도 중의적인 코드다.
- 함수 이름이 있는 함수 리터럴을 단독 사용하면 함수 선언문으로 해석하고
- 함수 리터럴이 값으로 평가되어야 하는 문맥 (변수에 할당)에선 함수 리터럴 표현식으로 사용된다.

```jsx
//기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
//함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() {console.log('foo')}
foo(); //foo

//함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
//함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() {console.log('bar')})
bar() //Erroe : bar is not defined
```

- 위 코드 foo는 함수 선언문으로 해석된다.
- ()내의 bar는 함수 리터럴 표현식으로 해석된다.
- 이름이 있는 기명함수 → 문맥따라 함수선언문 또는 함수 리터럴 표현식
- bar함수는 함수 이름으로 함수를 참조할 수 없으므로 함수 몸체 외부에서는 함수 이름으로 함수를 호출할 수 없다. 즉 함수를 가리키는 식별자가 없다는 것과 마찬가지다.

![Untitled 1](https://user-images.githubusercontent.com/76714485/133110054-4f1fb770-38e1-4625-a0e6-dde2df7ae0a8.png)


- foo는 자바스크립트 엔지인 암묵적으로 생성한 식별자다.

![Untitled 2](https://user-images.githubusercontent.com/76714485/133110069-c992df64-0b22-43da-b00c-2b308b5f6e19.png)


- 자바스크립트 엔지은 생성된 하수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 생성된 함수 객체를 할당한다.
- **함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 삭별자로 호출한다.**

![Untitled 3](https://user-images.githubusercontent.com/76714485/133110077-2554f78c-0fc4-4c22-b57f-aadbae129687.png)


### 4.2 함수 표현식

- 자바스크립트의 함수는 객체 타입의 값이다.
- 함수는 일급 객체이다.
- 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다.

```jsx
var add=funtion (x,y){
	return x+y;
}
```

- 함수 리터럴의 함수 이름은 생략할 수 있다.→ 익명함수이라 한다.
- 함수를 호출할 때는 함수 이름이 아니라 함수 객체를 가리키는 식별자를 사용해야 한다.
- 하지만 함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로 함수 이름으로 함수를 호출할 수 없다.

```jsx
var add=funtion foo(x,y){
	return x+y;
}

//함수 객체를 가리키는 식별자로 호출
console.log(add(2,5)) //7

//함수 이름으로 호출하면 referenceError가 발생한다.
console.log(foo(2,5)) //error L foo is not defined
```

- 자바스크립트 엔진은 함수 선언문은 함수 이름으로 식별자를 암묵적 생성하고 생성된 ㅎ마수 객체를 할당하므로 함수 표현식과 유사하게 동작하는 것처럼 보인다. 하지만 함수 선언문과 함수 표현식이 정확히 동일하게 동작하지는 않는다.

### 4.3 함수 생성 시점과 함수 호이스팅

```jsx
console.dir(add) // f add(x,y)
console.dir(sub) // undefined

//함수 선언문
function add(x,y){
	return x+y;
}

//함수 표현식
var sub=function (x ,y) {
	return x-y
}
```

- 위 예제를 보면
    - 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할수 있다.
    - 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.
- **함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 떄문이다.**
- 모든 선언문이 그렇듯 함수 선언문도 런타임 시점 이전에 자바스크립트 엔진에 의해 먼저 실행된다.
- 함수 선언문이 코드의 선두로 끌어 올련진 것처럼 동작하는 자바스크립트 교유의 특징을 함수 호이스팅이라 한다.
- var 키워드를 사용한 변수 선언문 이전에 변수를 참조하면서 변수 호이스팅에 의해 undefined로 평가 되지만 함수 선언문으로 정의된 함수를 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능하다.
- **변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.**
- **함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.**

![Untitled 4](https://user-images.githubusercontent.com/76714485/133110107-b1a503fe-939b-4d14-b8c9-cd87c3e8aeb8.png)


- 함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시한다.  → 더글라스 크락포드는 함수 선언문 대신 함수 표현식을 권장한다.

### 4.4 Function 생성자 함수

- 자바스크립트 기본 제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함꼐 호출하면 함수 객체를 생성해서 반환한다.

```jsx
var add=new Function('x', 'y', 'return x+y')
```

- Functnion → 일반적이지 않다. 바람직하지 않다. 클로저를 생성하지 않는다.

### 4.5 화살표 함수

- 화살표 함수는 항상 익명 함수로 정의한다.
- 화살표 함수는 표현만 간략한 것이 아니라 내부 동작 또한 간략화 되었다.
- 화살표함수는
- 생성자 함수로 사용할 수 없으며
- 기존의 함수와 this 바인딩 방식이 다르고
- prototype 프로퍼티가 없으며
- arguments 객체를 생성하지 않는다.

## 5. 함수 호출

- 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다.

### 5.1 매개변수와 인수

- 함수를 실행하기 위해 필요한 값을 외부에서 함수 내부로 전달할 필요가 있는 경우,
- 매개 변수를 통해 인수를 전달한다.
- 매개변수는 함수를 정의할 떄 선언하며 함수 몸체 내부에서 변수와 동일하게 취급된다.
- 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 →  undefined로 초기화 된후 → 인수가 순서대로 할당된다.
- 매개변수는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다.
- 매개변수의 스코프는 함수 내부이다.

```jsx
function add(x,y){
	console.log(x, y) //2 5
	return x+y;
}

add(2,5)

//add 함수의 매개변수 x,y는 함수 몸체 내부에서만 참조할 수 있다.
console.log(x,y)//referenceError : x is not defined
```

- 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다.
- 즉, 함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 일반적이지만 그렇지 않은 경우에도 에러가 발생하지않고 **부족한건 undefined이다.**
- 매개변수보다 인수가 더 많은 경우 초과된 인수는 무시된다.
- 초과된 인수가 그냥 버려지는 것은 아니다 → 암묵적으로 arguments 객체의 프로퍼티로 보관된다.
- 

```jsx
function add(x,y){
	console.log(arguments) 
//Arguments(3) [2,5,10, callee:f, Symbol(Symbol.iterator):f]
	return x+y;
}

add(2,5, 10)
```

- arguments 객체는 함수를 정의할 떄, 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용된다.

### 5.2 인수 확인

```jsx
function add(x,y){
	return x+y;
}

console.log(add('a','b')))//'ab'
```

- 자바스크립트는 동적 타입언어다. 따라서 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.

```jsx
function add(x,y){
if(typeof x!=='number' || typeof y!=='number'){
	throw new TypeError('type errror')
	return x+y;
}

console.log(add('a','b')))//'type errror'
```

- 이처럼 검사를 해도 에러는 런타임에 발생한다.
- arguments객체를 통해 인수 개수를 확인 할 수 있다.
- 인수가 전달되지 않은 경우 단축평가를 사용해 매개변수에 기본값을 할당하는 방법도 있다.

```jsx
function add(x,y,z){
	x=x || 0;
	y=y || 0
	z=z || 0;
	return x+y+z;
}

console.log(add(1)) //1
```

- ES6에 도입된 매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다.
- 매개변수 기본값은 → 매개변수에 인수를 전달하지 않았을 경우와 undefined를 전달한 경우에만 유효한다.

```jsx
function add(x=0, y=0, z=0){
	return x+y+z;
}

console.log(add(1)) //1
```

### 5.3 매개변수의 최대 개수

- ECMAScript 사양에서는 매개변수의 최대 개수에 대해 명시적으로 제한하지 않는다.
- 매개변수가 많아지면 → 사용법 이해 어렵, 실수 발생, 유지보수성이 나빠지다.
- 매개변수는 적을 수록 좋다.
- 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.
- 최대한 3개 이상을 넘지 않는 것을 권장한다.
- 그 이상이 필요하면 객체를 인수로 전달하는 것이 유리하다.
- 주의할 점은 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부수 효과가 발생한다.

### 5.4 반환문

- 함수 호출은 표현식이다.
- 함수 호출 표현식은 return 키워드가 반환한 표현식의 평가 결과 즉, 반환값으로 평가된다.
- 반환문은 2가지 역할을 한다.
    - 함수의 실행을 중단하고 함수 몸체를 빠져나간다.
    - 반환문 return 키워드 위에 오는 표현식을 평가해 반환한다. 지정하지 않으면 undefined
- 반환문은 생략할 수 있다. → 암묵적으로 undefined를 반환한다.
- return 키워드와 반환값으로 사용할 표현식 사이에 줄바꿈이 있으면 세미콜론 자동 삽입기능에 의해 세미콜론이 추가되어 의도치 않게 작동한다.

```jsx
function add(x,y){
	return //세미콜론이 추가된다.
	x+y; //무시된다.
}
```

## 6. 참조에 의한 전달과 외부 상태의 변경

- 원시값은 값에 의한전달, 객체는 참조에 의한 전달방식으로 동작한다.
- 매개변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 매개변수 또한 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식을 그대로 따른다.

```jsx
function changeVal(primitive, obj){
	primitive+=100
	obj.name='kim'
}

var num=100;
var person={name : 'Lee'}

changeVal(num, person)

//d원시값은 원본이 훼손도지 않고 객체는 원본이 훼손된다.
console.log(num) //100
console.log(person) //{name : 'kim'}
```

- 원시 타입 인수 → 원시 타입 인수를 전달받은 매개변수의 경우, 원시값은 변경 불가능한 값이므로 직접 변경할 수 없기 때문에 재할당을 통해 할당된 원시값을 새로운 원시값으로 교체했고
- 객체 타입 인수 → 객체는 변경 가능한 값이므로 직접 변경할 수 있기 때문에 재할당 없이 직접 할당된 객체를 변경했다.

![Untitled 5](https://user-images.githubusercontent.com/76714485/133110159-a4ceb2e6-a7a7-48a3-aea4-fd114e38b92f.png)


- 함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워진다.
- 이러한 현상은 객체가 변경할 수 있는 값이며, 참조에 의한 전달 방식으로 동작하기 때문에 발생하는 부작용이다.
- 객체 변경을 추적하려면 옵저버 패턴등을 통해 객체를 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처하는 추가 대응이 필요하다.
- 문제 해결방식 중 하나 → 객체를 불변 객체로 만들어 사용한든 것이다.
- 불변 객체 → 객체의 복사본을 새롭게 생성, 원시값 처럼 동작하게함
- 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체한다.
- 순수 함수 → 외부 상태에 의존하지도 않는 함수'

## 7. 다양한 함수의 형태

### 7.1 즉시 실행 함수

- 함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라 한다.
- 즉시 실행 함수는 단 한번만 호출되며 다시 호출할 수 없다.

```jsx
(function (){
	var a=3
	var b=5
	return a*b;
}())
```

- 익명 함수를 사용하는 것이 일반적이다.
- 기명 함수를 사용해도 다시 호출할 수 없다.
- 즉시 실행 함수는 반듯기 그룹 연산자 () 로 감싸야 한다.

```jsx
funtion foo(){}(); // => function foo() {};();
```

- 그룹 연산자의 피연산자는 값으로 평가되므로 기명 또는 무명 함수를 그룹 연산자로 감싸면 함수 리터럴로 평가되어 함수 객체가 된다.

```jsx
console.log(typeof (funtion f(){}))) //function
console.log(typeof (funtion (){}))) //function
```

- 그룹 연산자로 함수를 묶은 이유는 먼저 함수 리터럴을 평가해서 함수 객체를 생성하기 위해서다.
- 따라서 먼저 함수 리터럴을 평가해서 함수 객체를 생성할 수 있다면 다음과 같이 그룹 연산자 이외의 연산자를 사용해도 좋다.

```jsx
(function (){
	//...
}())
```

- 즉시 실행 함수도 값을 반활할 수 있고 인수를 전달할 수 도 있다.

```jsx
//즉시 실행 함수에도 반환 가능
var res=(function (){
	var a=3
	var b=5
	return a*b;
}())

console.log(res); //15

//즉시 실행 함수에도 인수 전달 가능

var res=(function (a,b){
	return a*b;
}(3,5))

console.log(res); //15
```

### 7.2 재귀 함수

- 탈출 조건을 반드시 필요하다.

### 7.3 중첩 함수

- 함수 내부에 정의된 함수를 중첩함수 또는 내부 함수라 한다.
- 중첩 함수를 포함하는 함수는 외부 함수라 한다.

```jsx
function outer(){
	var x=1;

	function inner(){
		var y=2;
		// 외부 함수의 변수를 참조할 수 있다.
		console.log(x+y); //3
	}
inner()
}

outer()

```

- Es6부터 함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능하다.
- 단, 호이스팅으로 인해 혼란이 발생할 수 있으므로 if문이나 for문에는 바람직하지 않다.

### 7.4 콜백 함수

```jsx
function reapea(n){
	for(var i=0;i<n;i++) console.log(i)
}

repeat(5) // 0 1 2 3 4
```

- repeat 함수의 반복문 내부에서 다른 일을 하고 싶다면 함수를 새롭게 정의해야 한다.

```jsx
function reapea(n){
	for(var i=0;i<n;i++){
	 
		if (i%2) console.log(i)
	}
}

repeat(5) // 1 3
```

- 위 예제의 함수들은 반복하는 일은 변하지 않고 공통적으로 수행하지만 반복하면서 하는 일의 내용은 다르다.
- 함수의 일부분만이 다르기 때문에 매번 함수를 새롭게 정의해야 하나
→ 함수를 합성하는 것으로 해결할 수 있다.

```jsx
function repeat(n, f){
	for (var i=0; i<n; i++){
		f(i);
	}
}

var logAll=function (i) {
	console.log(i);
};

repeat(5, logAll); // 0 1 2 3 4

var logOdds=function (i) {
	if (i%2) console.log(i);
};

repeat(5, logOdds); // 1 3
```

- repeat→ 경우에 따라 변경되는 일을 함수 f로 추상화 했고 이를 외부에서 전달 받는다.
- 함수는 일급 객체이므로 함수의 매개변수를 통해 전달 가능
- repeat는 외부에서 로직의 일부분을 함수로 전달받아 수행하므로 더욱 유연한 구조를 갖게 되었다.
- **콜백함수 → 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수라 한다.**
- **고차함수 → 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받음 함수를 고차함수라 한다.**
- 중첩 함수는 → 고정되어 있어서 교체하기 곤란하다
- 콜백 함수 → 자유롭게 교체할 수 있다.
- **고차 함수 → 고차함수는 콜백함수를 자신의 일부분으로 합성한다.**
- **고차 함수 → 매개변수를 통해전달받은 콜백 함수의 시점을 결정해서 호출한다**
- **콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.**
- 콜백 함수가 고차 함수 내부에만 호출 된다면 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하는 것이 일반적이다.

```jsx
//익명 함수 리터럴은 repeat 함수를 호출할 때마다 평가되어 함술 객체를 생성한다.

repeat(5,function(i){
	if (i%2) console.log(i);
}) //1 3
```

- 콜백 함수를 다른 곳에서도 호출할 필요가 있거나, 콜백함수를 전달받는 함수가 자주 호출된다면 함수 외부에서 콜백 함수를 정의한 후 참조를 하는게 효율적이다.
- 콜백함수는 → 함수형 프로그래밍 패러다임, 비동기 처리(이벤트 처리, Ajax, Timer)에 활용되는 중요한 패턴이다.

```jsx
// 콜백 함수를 사용한 이벤트 처리
//myButton 버튼을 클릭하면 콜백 함수를 실행한다.
document.getElementById('myButton').addEventListener('click',function(){
	console.log('clicked')
})

//콜백 함수를 사용한 비동기 처리
// 1초 후에 메시지를 출력한다.
setTimeout(function () {
	console.log('1초 초과');
}, 1000);
```

- 콜백함수는 배열 고차 함수에도 사용된다. (map, filter, reduce)

### 7.5 순수 함수와 비순수 함수

- 순수 함수 → 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 부수 효과가 없는 함수
- 비순수 함수 → 외부 상태에 의존하거나 외부 상태를 변경하는, 부수효과가 있는 함수
- 순수 함수 → 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수다.
- 외부 상태란 → 전역변수, 서버 데이터 , 파일, Console, DOM 등이 있다.
- 만약 함수 내부 상태에만 의존한다 해도 그 내부 상태가 호출될 떄 마다 변화는 값(현재 시각)이라면 순수 함수가 아니다.
- 순수함수 → 일반적으로 최소 하나 이상의 인수를 전달 받는다.
- 순수 함수 → 인수를 변경하지 않는 것이 기본이다. 인수의 불변성을 유지한다.

```jsx
var count=0

// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환하다.
function increase(n){
	return ++n;
}
```

- 비순수 함수 → 외부 상태에 의존해서 부수 효과가 있다.

```jsx
var count=0

//비순수 함수
function increase(){
	return ++count; // 외부 상태에 의존하며 외부 상태를 변경한다.
}
```

- 함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워진다.
- 함수형 프로그래밍은 순수 함수와 보조함수의 조합을 통해 외부 상태를 변경하려는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임이다.
- 로직 내에 존재하는 조건문, 반복문을 제거해서 복잡성을 해결하며, 변수 사용을 어젝하거나 생명주기를 최소화 해서 상태 변경을 피해 오류를 최소화 하는것을 목표로 한다.
- 자바스크립트는 멀티 패러다임 언어이므로 객체지향 프로그래밍 뿐만 아니라 함수형 프로그래밍을 적극적으로 활용하고 있다.
