# 11. 원시값과 객체의 비교

- 자바스크립트가 제공하는 7가지 데이터 타입(숫자, 문자열, 불리언, null, undefined, 심벌, 객체타입)은 **크게 원시타입과 객체 타입으로 구분할 수 있다.**
- 원시 타입과 객체 타입의 차이점
- 원시 타입의 값 → 즉 원시값은 변경 불가능한 값(immutable value)이다.
- 객체 타입의 값 → 객체는 변경 가능한 값이다.
- 원시값을 변수에 할당하면 → 변수에는 실제 값이 저장된다.
- 객체를 변수에 할당하면 → 변수에는 참조값이 저장된다.
- 원시값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달된다.(pass by value)
- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 전달된다. (pass by reference)

## 1. 원시값

### 1.1 변경 불가능한 값

- 원시 타입의(primitive type) 값, 즉 원시값은 변경 불가능한 값이다.
- 위의 말은 즉슨 → 원시값 자체를 변경할 수 없다는 것이지, 변수 값을 변경할 수 없다는 것이 아니다.
- 변수는 언제든지 재할당을 통해 변수 값을 변경(교체)할 수 있다.
- 변수는 언제든지 재할당 통해 교체 할 수있지만 상수는 교체할 수 없다.

```jsx
// const 키워드를 사용해 선언한 변수는 재할당이 금지된다. 상수는 재할당이 금지된 변수 일뿐이다.
const o ={};

//const 키워드를 사용해 선언한 변수에 할당한 원시값은 변경할 수 없다.
//하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있다.
o.a=1
console.log(o); //{a:1}
```

- 원시값을 할당한 변수에 새로운 원시값을 재할당하면 메모리  공가에 저장되어 있는 재할당 이전의 원시값을 변경하는것이 아니라 새로운 메모리 공간을 확보하고 재할당한 원시값을 정장한 후 변수는 새롭게 재할당한 원시값을 가리킨다. 이때 변수가 참조하던 메모리 공간의 주소가 바뀐다.

![Untitled](https://user-images.githubusercontent.com/76714485/132954405-2bae07e8-8b13-4950-b7a4-a48218e28bbf.png)

- 변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시값이 변경 불가능한 값이기 때문이다.
- 원시값의 이런한 특성을 분변성이라 한다.
- **불변성을 갖는 원시값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법은 없다.**

### 1.2 문자열과 불변성

- 원시값을 저장하려면 먼저 확보해야 하는 메모리 공간의 크기를 결정해야 한다.
- 문자열은 0개 이상의 문자로 이뤄진 집합을 말한다.
- 1개의 문자는 2바이트의 메모리 공간에 저장된다.(숫자는 8바이트)
- 따라서 문자열은 몇 개의 문자로 이뤄졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다.
- 자바스크립트의 문자열은 원시 타입이며, 변경불가능하다.

```jsx
var str='Hello'
str='world'

//문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근가능하다.
//하지만 문자열은 원시값이므로 변경할 수 없다.
str[0]='W'
console.log(str)//world
```

- 첫줄이 실행되면 Hello가 생성되고str은 문자열 Hello가 저장된 메모리 공간의 첫번째 메모리 셀 주소를 가리킨다.
- 두번째 줄은 'world'를 메모리에 생성하고 식별자 str은 이것을 가리킨다.
- 문자열은 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.
- 한번 생성된 문자열은 읽기 전용 값으로서 변경할 수 없다.

### 1.3 값에 의한 전달

```jsx
var score=80
var copy=score

console.log(score) //80
console.log(copy) //80

score=100

console.log(score) //100
console.log(copy) //80
```

- 변수 copy에 할당되는 변수 score의 원시값이 복사되어 전달된다.(pass by value)
- 위 코드경우 copy 변수에 원시값을 갖는 score 변수를 할당하면 변수 copy에는 할당되나느 변수 score의 원시값 80이 복사되어 전달된다.

```jsx
var score=80
var copy=score

console.log(score, copy) //80 80
console.log(score===copy) //true

 socre=100
console.log(score===copy) //false
```
![Untitled 1](https://user-images.githubusercontent.com/76714485/132954417-d2573574-4345-4c99-adf4-136d8271535c.png)

- score와 copy는 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.
- "값에의한 전달"은 **엄격하게 표현하면 변수에는 값이 전달되는것이 아니라 메모리 주소가 전달되기 때문이다. 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.**
- 식별자 → 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 것을 의마한다. 즉 식별자는 메모리 주소에 붙인 이름이라고 할 수 있다.
- 

```jsx
var copy=score
```

- 위 예제는 두가지 평가 방식이 가능하다.
    - 새로운 80을 생성해서 메모리 주소를 전달하는 방식. 이 방식은 할당 시점에 두 변수가 기억하는 메모리 주소가 다르다.
    - socre의 변수값 80의 메모리 주소를 그대로 전달하는 방식. 이 방식은 할당 시점에서 두 변수가 기억하는 메모리 주소가 같다.
- **이처럼 " 값에 의한 절달"도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달한다. 단 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.**
- **결국은 두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.**

## 2. 객체

- 객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되 삭제할 수 있다.
- 또한 프로퍼티의 값에도 제약이 없다.
- 따라서 객체는 원시값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.
- 객체는 원시값과는 다른 방식으로 동작하도록 설계되어 있다.

### 2.0 자바스크립트의 객체의 관리 방식

- 자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 생각할 수 있다.
- 자바스크립트는 클래스 없이 객체를 생성할 수 있으며 객체가 생성된 이후라도 동적으로 프로퍼티와 메서드를 추가할 수 이싿.
- 이는 객체지향 프로그래밍 언어의 객체보다 생성과 프로퍼티 접근에 비용이 더 많이 드는 비효율적인 방식이다.
- V8  자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 동적 탐색 대신 **히든클래스 방식**을 사용해 c++객체의 프로퍼티에 접근하는 정도의 성능을 보장한다.

### 2.1 변경 가능한 값

- 객체 → 객체는 변경 가능한 값이다.

```jsx
var person={
	name:'Lee'
}
```

- 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조값(reference value**)에 접근할 수 있다.

![Untitled 2](https://user-images.githubusercontent.com/76714485/132954426-de21115c-9e6e-42f1-8dd1-2005fe4e3dc7.png)

- 객체를 할당한 변수에는 생성된 객체가 실제로 저장된 메모리 공간의 주소가 저장죄어 있다.
- 이값을 참조값이라고 한다.
- 변수는 이 참조값을 통해 객체에 접근할 수 있다.
- 원시값을 할당하는 변수 →> 변수 0값을 갖는다.
- 객체를 할당하는 변수 → 변수는 객체를 참조하고 있다.
- 원시값은 변경 불가능한 값이므로 원시값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없다.
- 객체는 변경 가능한 값이다. 따라서 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다.
- 즉 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수 도 있으며 프로퍼티 자체를 삭제할 수 도 있다.

![Untitled 3](https://user-images.githubusercontent.com/76714485/132954436-0e043f62-6ee2-421f-942b-88d2fa5cf6d1.png)

- 메모리를 효율적으로 사용하기 위해, 그리고 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계되어 있다.
- **부작용 → 여러 개의 식별자가 하나의 객체를 공유할 수 있다.**
- 얕은 복사 → 객체를 프로퍼티 값으로 갖는 객체의 경우 한단계까지만 복사하는것
- 깊은 복사 → 객체에 중첩되어 있는 객체까지 모두 복사하는것

```jsx
const o={
	a:{
		b:2
	},
	f() {}
};

//얕은 복사
let c ={...o}
console.log(o===c) //false
console.log(o.a===c.a) //true

c=Object.assign({},o)
console.log(o===c) //false
console.log(o.a===c.a) //true

//깊은 복사
c=JSON.parse(JSON.stringfy(o))
console.log(o===c) //false
console.log(o.a===c.a) //false
console.log(c.f) //메서드 사라짐 undefined

//lodash의 cloneDeep을 사용한 깊은 복사
const _ = require('lodash')
c=_.cloneDeep(o)
console.log(o===c) //false
console.log(o.a===c.a) //false
console.log(c.f) //f
```

- 얕은복사와 깊은복사로 생성된 객체는 원본과는 다른 객체다.
- 즉 원본과 복사본은 참조값이 다른 별개의 객체다.
- 얕은 복사 → 객체에 중첩되어 있는 객체의 경우 참조값을 복사하고 
- 깊은 복사 → 객체에 중첩되어 있는 객체까지 모두 복사해서 원시값처럼 완전한 복사본을 만든다는 차이가 잇따.
- 얕은 복사 → 객체를 할당한 변수를 다른 변수에 할당하는 것
- 깊은 복사 → 원시값을 할당한 변수를 다른 변수에 할당하는 것

### 2.2 참조에 의한 전달

- 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이 무엇이고 부작용이 무엇인지

```jsx
var person={
	name:'Lee'
}

var copy=person
```

![Untitled 4](https://user-images.githubusercontent.com/76714485/132954441-26ccf35a-1004-4d10-a1bc-b22be9b32464.png)

- 동일한 참조값을 갖는다.
- person, copy둘다 동일한 객체를 가리킨다.
- 따라서 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다

```jsx
var person={
	name:'Lee'
}

var copy=person

copy.name='Kim'
person.adress='Seoul'

console.log(person) //{name : 'kim', address : "Seoul"}
console.log(copy) //{name : 'kim', address : "Seoul"}

```

- "값에 의한 전달", "참조에 의한 전달" 은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다.
- 자바스크립트에는 "참조에 의한 전달"은 존재하지 않고 "값에 의한 전달"만이 존잰한다고 할 수 있다.
